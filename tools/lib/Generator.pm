package Generator;

use v5.30;
use strict;
use warnings;
use autodie qw( :all );
use experimental qw( signatures );
use feature qw( postderef );

use Devel::Confess;
use IPC::Run3 qw( run3 );
use JSON::MaybeXS qw( decode_json );
use Path::Tiny qw( path );
use Specio::Library::Builtins;
use Specio::Library::Path::Tiny;
use String::CamelSnakeKebab qw( lower_snake_case upper_camel_case );

use Generator::Enum;
use Generator::NodeEnum;
use Generator::Struct;
use Generator::WrapperEnum;

use Moose;

## no critic (TestingAndDebugging::ProhibitNoWarnings)
no warnings qw( experimental::postderef experimental::signatures );
## use critic

with 'MooseX::Getopt::Dashes';

MooseX::Getopt::OptionTypeMap->add_option_type_to_map(
    t('Dir') => '=s',
);
MooseX::Getopt::OptionTypeMap->add_option_type_to_map(
    t('Path') => '=s',
);

has from => (
    is            => 'ro',
    isa           => t('Dir'),
    coerce        => 1,
    required      => 1,
    documentation => 'The root directory of the libpg_query code',
);

has to => (
    is            => 'ro',
    isa           => t('Path'),
    coerce        => 1,
    required      => 1,
    documentation => 'The file to which to write the generated code',
);

has _enum_defs => (
    is      => 'ro',
    isa     => t('HashRef'),
    lazy    => 1,
    builder => '_build_enum_defs',
);

has _seen_enums => (
    is      => 'ro',
    isa     => t('HashRef'),
    lazy    => 1,
    default => sub { {} },
);

has _struct_defs => (
    is      => 'ro',
    isa     => t('HashRef'),
    lazy    => 1,
    builder => '_build_struct_defs',
);

has _structs_to_wrap => (
    is      => 'ro',
    isa     => t('HashRef'),
    lazy    => 1,
    default => sub {
        {
            ResTarget    => 1,
            SelectStmt   => 1,
            StringStruct => 1,
        }
    },
);

has _node_types => (
    is      => 'ro',
    isa     => t('ArrayRef'),
    lazy    => 1,
    builder => '_build_node_types',
);

sub _build_enum_defs ($self) {
    my $enums
        = decode_json(
        $self->from->child(qw( srcdata enum_defs.json ))->slurp_utf8 );
    my %enums = map { $_->%* } values $enums->%*;

    # See https://github.com/lfittl/libpg_query/issues/74.
    push $enums{BoolExprType}{values}->@*, { name => 'NOT_EXPR' };
    return \%enums;
}

my %wanted_struct_paths = map { $_ => 1 } qw(
    nodes/parsenodes
    nodes/primnodes
    nodes/value
);

sub _build_struct_defs ($self) {
    my $structs
        = decode_json(
        path( $self->from, qw( srcdata struct_defs.json ) )->slurp_utf8 );
    return {
        map  { $_->%* }
        map  { $structs->{$_} }
        grep { $wanted_struct_paths{$_} } keys $structs->%*
    };
}

sub _build_node_types ($self) {
    return [
        # see https://github.com/lfittl/libpg_query/issues/69
        grep { !/\A[a-z]/ } decode_json(
            path( $self->from, qw( srcdata nodetypes.json ) )->slurp_utf8
        )->@*
    ];
}

my $GeneratedMsg = sprintf( <<'EOF', path($0)->basename );
// This code was generated by the %s script in the pg-pretty repo. Don't edit
// it by hand except for debugging purposes.
EOF

sub run ($self) {
    my $to = $self->to;
    die "No file at $to" unless $to->exists;

    my $code = $self->_rust_code;

    my $orig_content = $to->slurp_utf8;
    my $new_content  = $orig_content
        =~ s{(\n// <<< begin generated code)\n+.+\n(// end generated code >>>)}{$1\n//\n$GeneratedMsg\n$code\n\n$2}sr;

    my ( $stdout, $stderr );
    run3(
        [qw( rustfmt --emit stdout )],
        \$new_content,
        \$stdout,
        \$stderr,
    );
    die "rustfmt stderr:\n$stderr\n$new_content" if $stderr;
    die 'rustfmt exited non-0'                   if $?;

    # Every time we touch this file cargo rebuilds it.
    if ( $stdout ne $orig_content ) {
        $to->spew_utf8($new_content);
        system( 'rustfmt', $to );
    }

    return 0;
}

sub _rust_code ($self) {
    my $code = q{};
    for my $name ( sort keys $self->_struct_defs->%* ) {
        my $struct = Generator::Struct->new(
            c_name        => $name,
            known_enums   => $self->_enum_defs,
            known_structs => $self->_struct_defs,
            $self->_struct_defs->{$name}->%*,
        );
        $code .= $struct->as_rust;
        $code .= "\n";

        $self->_structs_to_wrap->{$_} = 1 for $struct->referenced_structs;
        $self->_seen_enums->{$_}      = 1 for $struct->referenced_enums;
    }

    for my $name ( sort keys $self->_seen_enums->%* ) {
        my $enum = $self->_enum_defs->{$name}
            // die "Could not find an enum named $name";
        $code .= Generator::Enum->new(
            c_name => $name,
            $enum->%*,
        )->as_rust;
        $code .= "\n";
    }

    $code .= $self->_node_enum;
    $code .= "\n";

    for my $name ( sort keys $self->_structs_to_wrap->%* ) {
        $code .= Generator::WrapperEnum->new( rust_name => $name )->as_rust;
        $code .= "\n";
    }

    $code =~ s/\n+$//;

    return $code;
}

sub _node_enum ($self) {
    my @nodes = grep { $self->_struct_defs->{$_} } $self->_node_types->@*;
    return Generator::NodeEnum->new( nodes => \@nodes )->as_rust;
}

__PACKAGE__->meta->make_immutable;

1;
