use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};
use serde_with::skip_serializing_none;

pub type AclMode = u32;
pub type AttrNumber = i16;
pub type Index = u64;
pub type List = Vec<Node>;
pub type Oid = u64;

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum Root {
    RawStmt(RawStmt),
}

// Providing some enums that are simpler than Node for certain fields
// simplifies handling of this data. There are many cases where structs
// contain a `List*` but in reality they only have one or a few types of
// members. So for example processing a Vec<ColumnRefField> is much simpler
// than Vec<Node>, because ColumnRefField has just two variants.

#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(untagged)]
pub enum OneOrManyNodes {
    One(Box<Node>),
    Many(Vec<Node>),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum ColumnRefField {
    #[serde(rename = "String")]
    StringStruct(StringStruct),
    AStar(AStar),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum Value {
    BitString(BitString),
    Integer(Integer),
    Float(Float),
    Null(Null),
    #[serde(rename = "String")]
    StringStruct(StringStruct),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum StringOrTypeName {
    #[serde(rename = "String")]
    StringStruct(StringStruct),
    TypeName(TypeName),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(untagged)]
pub enum DefElemArgs {
    One(StringOrTypeName),
    Many(Vec<StringOrTypeName>),
}

// <<< begin generated code
//
// This code was generated by the json-to-parser.pl script in the pg-pretty repo. Don't edit
// it by hand except for debugging purposes.

// A_ArrayExpr - an ARRAY[] construct
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename = "A_ArrayExpr")]
pub struct AArrayExpr {
    // array element expressions
    pub elements: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// A_Const - a literal constant
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename = "A_Const")]
pub struct AConst {
    // value (includes type info, see value.h)
    pub val: Value, // Value
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// A_Expr - infix, prefix, and postfix expressions
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename = "A_Expr")]
pub struct AExpr {
    // see above
    pub kind: AExprKind, // A_Expr_Kind
    // possibly-qualified name of operator
    pub name: Option<List>, // List*
    // left argument, or NULL if none
    pub lexpr: Box<Node>, // Node*
    // right argument, or NULL if none
    pub rexpr: OneOrManyNodes, // Node*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// A_Indices - array subscript or slice bounds ([idx] or [lidx:uidx])
// In slice case, either or both of lidx and uidx can be NULL (omitted).
// In non-slice case, uidx holds the single subscript and lidx is always NULL.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename = "A_Indices")]
pub struct AIndices {
    // true if slice (i.e., colon present)
    #[serde(default)]
    pub is_slice: bool, // bool
    // slice lower bound, if any
    pub lidx: Option<Box<Node>>, // Node*
    // subscript, or slice upper bound if any
    pub uidx: Option<Box<Node>>, // Node*
}

// A_Indirection - select a field and/or array element from an expression
// The indirection list can contain A_Indices nodes (representing
// subscripting), string Value nodes (representing field selection --- the
// string value is the name of the field to select), and A_Star nodes
// (representing selection of all fields of a composite type).
// For example, a complex selection operation like
// (foo).field1[42][7].field2
// would be represented with a single A_Indirection node having a 4-element
// indirection list.
// Currently, A_Star must appear only as the last list element --- the grammar
// is responsible for enforcing this!
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename = "A_Indirection")]
pub struct AIndirection {
    // the thing being selected from
    pub arg: Option<Box<Node>>, // Node*
    // subscripts and/or field names and/or *
    pub indirection: Option<List>, // List*
}

// A_Star - '*' representing all columns of a table or compound field
// This can appear within ColumnRef.fields, A_Indirection.indirection, and
// ResTarget.indirection lists.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename = "A_Star")]
pub struct AStar {}

// An access privilege, with optional list of column names
// priv_name == NULL denotes ALL PRIVILEGES (only used with a column list)
// cols == NIL denotes "all columns"
// Note that simple "ALL PRIVILEGES" is represented as a NIL list, not
// an AccessPriv with both fields null.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AccessPriv {
    // string name of privilege
    pub priv_name: Option<String>, // char*
    // list of Value strings
    pub cols: Option<Vec<StringStructWrapper>>, // List*
}

// Aggref
// The aggregate's args list is a targetlist, ie, a list of TargetEntry nodes.
// For a normal (non-ordered-set) aggregate, the non-resjunk TargetEntries
// represent the aggregate's regular arguments (if any) and resjunk TLEs can
// be added at the end to represent ORDER BY expressions that are not also
// arguments.  As in a top-level Query, the TLEs can be marked with
// ressortgroupref indexes to let them be referenced by SortGroupClause
// entries in the aggorder and/or aggdistinct lists.  This represents ORDER BY
// and DISTINCT operations to be applied to the aggregate input rows before
// they are passed to the transition function.  The grammar only allows a
// simple "DISTINCT" specifier for the arguments, but we use the full
// query-level representation to allow more code sharing.
// For an ordered-set aggregate, the args list represents the WITHIN GROUP
// (aggregated) arguments, all of which will be listed in the aggorder list.
// DISTINCT is not supported in this case, so aggdistinct will be NIL.
// The direct arguments appear in aggdirectargs (as a list of plain
// expressions, not TargetEntry nodes).
// aggtranstype is the data type of the state transition values for this
// aggregate (resolved to an actual type, if agg's transtype is polymorphic).
// This is determined during planning and is InvalidOid before that.
// aggargtypes is an OID list of the data types of the direct and regular
// arguments.  Normally it's redundant with the aggdirectargs and args lists,
// but in a combining aggregate, it's not because the args list has been
// replaced with a single argument representing the partial-aggregate
// transition values.
// aggsplit indicates the expected partial-aggregation mode for the Aggref's
// parent plan node.  It's always set to AGGSPLIT_SIMPLE in the parser, but
// the planner might change it to something else.  We use this mainly as
// a crosscheck that the Aggrefs match the plan; but note that when aggsplit
// indicates a non-final mode, aggtype reflects the transition data type
// not the SQL-level output type of the aggregate.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Aggref {
    // pg_proc Oid of the aggregate
    pub aggfnoid: Option<Oid>, // Oid
    // type Oid of result of the aggregate
    pub aggtype: Option<Oid>, // Oid
    // OID of collation of result
    pub aggcollid: Option<Oid>, // Oid
    // OID of collation that function should use
    pub inputcollid: Option<Oid>, // Oid
    // type Oid of aggregate's transition value
    pub aggtranstype: Option<Oid>, // Oid
    // type Oids of direct and aggregated args
    pub aggargtypes: Option<List>, // List*
    // direct arguments, if an ordered-set agg
    pub aggdirectargs: Option<List>, // List*
    // aggregated arguments and sort expressions
    pub args: Option<List>, // List*
    // ORDER BY (list of SortGroupClause)
    pub aggorder: Option<Vec<SortGroupClauseWrapper>>, // List*
    // DISTINCT (list of SortGroupClause)
    pub aggdistinct: Option<Vec<SortGroupClauseWrapper>>, // List*
    // FILTER expression, if any
    pub aggfilter: Option<ExprWrapper>, // Expr*
    // TRUE if argument list was really '*'
    #[serde(default)]
    pub aggstar: bool, // bool
    // true if variadic arguments have been
    // combined into an array last argument
    #[serde(default)]
    pub aggvariadic: bool, // bool
    // aggregate kind (see pg_aggregate.h)
    pub aggkind: char, // char
    // > 0 if agg belongs to outer query
    pub agglevelsup: Option<Index>, // Index
    // expected agg-splitting mode of parent Agg
    pub aggsplit: Option<AggSplit>, // AggSplit
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Alias -
// specifies an alias for a range variable; the alias might also
// specify renaming of columns within the table.
// Note: colnames is a list of Value nodes (always strings).  In Alias structs
// associated with RTEs, there may be entries corresponding to dropped
// columns; these are normally empty strings ("").  See parsenodes.h for info.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Alias {
    // aliased rel name (never qualified)
    pub aliasname: String, // char*
    // optional list of column aliases
    pub colnames: Option<Vec<StringStruct>>, // List*
}

// Alter Collation
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterCollationStmt {
    pub collname: Option<List>, // List*
}

// Alter Database
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterDatabaseSetStmt {
    // database name
    pub dbname: Option<String>, // char*
    // SET or RESET subcommand
    pub setstmt: Option<VariableSetStmtWrapper>, // VariableSetStmt*
}

// Alter Database
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterDatabaseStmt {
    // name of database to alter
    pub dbname: Option<String>, // char*
    // List of DefElem nodes
    pub options: Vec<DefElemWrapper>, // List*
}

// Alter Default Privileges Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterDefaultPrivilegesStmt {
    // list of DefElem
    pub options: Vec<DefElemWrapper>, // List*
    // GRANT/REVOKE action (with objects=NIL)
    pub action: Option<GrantStmtWrapper>, // GrantStmt*
}

// Alter Domain
// The fields are used in different ways by the different variants of
// this command.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterDomainStmt {
    // T = alter column default
    // N = alter column drop not null
    // O = alter column set not null
    // C = add constraint
    // X = drop constraint
    pub subtype: Option<char>, // char
    // domain to work on
    #[serde(rename = "typeName")]
    pub type_name: List, // List*
    // column or constraint name to act on
    pub name: Option<String>, // char*
    // definition of default or constraint
    pub def: Option<Box<Node>>, // Node*
    // RESTRICT or CASCADE for DROP cases
    pub behavior: Option<DropBehavior>, // DropBehavior
    // skip error if missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// Alter Type Statement, enum types
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterEnumStmt {
    // qualified name (list of Value strings)
    #[serde(rename = "typeName")]
    pub type_name: Vec<StringStructWrapper>, // List*
    // old enum value's name, if renaming
    #[serde(rename = "oldVal")]
    pub old_val: Option<String>, // char*
    // new enum value's name
    #[serde(rename = "newVal")]
    pub new_val: Option<String>, // char*
    // neighboring enum value, if specified
    #[serde(rename = "newValNeighbor")]
    pub new_val_neighbor: Option<String>, // char*
    // place new enum value after neighbor?
    #[serde(default, rename = "newValIsAfter")]
    pub new_val_is_after: bool, // bool
    // no error if new already exists?
    #[serde(default, rename = "skipIfNewValExists")]
    pub skip_if_new_val_exists: bool, // bool
}

// Alter EVENT TRIGGER Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterEventTrigStmt {
    // TRIGGER's name
    pub trigname: Option<String>, // char*
    // trigger's firing configuration WRT
    // session_replication_role
    pub tgenabled: Option<char>, // char
}

// Create/Alter Extension Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterExtensionContentsStmt {
    // Extension's name
    pub extname: Option<String>, // char*
    // +1 = add object, -1 = drop object
    pub action: Option<i64>, // int
    // Object's type
    pub objtype: Option<ObjectType>, // ObjectType
    // Qualified name of the object
    pub object: Option<Box<Node>>, // Node*
}

// Only used for ALTER EXTENSION UPDATE; later might need an action field
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterExtensionStmt {
    pub extname: Option<String>, // char*
    // List of DefElem nodes
    pub options: Vec<DefElemWrapper>, // List*
}

// Create/Alter FOREIGN DATA WRAPPER Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterFdwStmt {
    // foreign-data wrapper name
    pub fdwname: Option<String>, // char*
    // HANDLER/VALIDATOR options
    pub func_options: Option<List>, // List*
    // generic options to FDW
    pub options: Option<List>, // List*
}

// Create/Alter FOREIGN SERVER Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterForeignServerStmt {
    // server name
    pub servername: Option<String>, // char*
    // optional server version
    pub version: Option<String>, // char*
    // generic options to server
    pub options: Option<List>, // List*
    // version specified
    #[serde(default)]
    pub has_version: bool, // bool
}

// Create Function Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterFunctionStmt {
    // name and args of function
    pub func: Option<ObjectWithArgsWrapper>, // ObjectWithArgs*
    // list of DefElem
    pub actions: Option<Vec<DefElemWrapper>>, // List*
}

// ALTER object DEPENDS ON EXTENSION extname
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterObjectDependsStmt {
    // OBJECT_FUNCTION, OBJECT_TRIGGER, etc
    #[serde(rename = "objectType")]
    pub object_type: Option<ObjectType>, // ObjectType
    // in case a table is involved
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // name of the object
    pub object: Option<Box<Node>>, // Node*
    // extension name
    pub extname: Option<Value>, // Value*
}

// ALTER object SET SCHEMA Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterObjectSchemaStmt {
    // OBJECT_TABLE, OBJECT_TYPE, etc
    #[serde(rename = "objectType")]
    pub object_type: Option<ObjectType>, // ObjectType
    // in case it's a table
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // in case it's some other object
    pub object: Option<Box<Node>>, // Node*
    // the new schema
    pub newschema: Option<String>, // char*
    // skip error if missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// Alter Operator Family Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterOpFamilyStmt {
    // qualified name (list of Value strings)
    pub opfamilyname: Vec<StringStructWrapper>, // List*
    // name of index AM opfamily is for
    pub amname: Option<String>, // char*
    // ADD or DROP the items?
    #[serde(default, rename = "isDrop")]
    pub is_drop: bool, // bool
    // List of CreateOpClassItem nodes
    pub items: Option<Vec<CreateOpClassItemWrapper>>, // List*
}

// Alter Operator Set Restrict, Join
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterOperatorStmt {
    // operator name and argument types
    pub opername: Option<ObjectWithArgsWrapper>, // ObjectWithArgs*
    // List of DefElem nodes
    pub options: Vec<DefElemWrapper>, // List*
}

// Alter Object Owner Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterOwnerStmt {
    // OBJECT_TABLE, OBJECT_TYPE, etc
    #[serde(rename = "objectType")]
    pub object_type: Option<ObjectType>, // ObjectType
    // in case it's a table
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // in case it's some other object
    pub object: Option<Box<Node>>, // Node*
    // the new owner
    pub newowner: Option<RoleSpecWrapper>, // RoleSpec*
}

// Alter POLICY Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterPolicyStmt {
    // Policy's name
    pub policy_name: Option<String>, // char*
    // the table name the policy applies to
    pub table: Option<RangeVarWrapper>, // RangeVar*
    // the roles associated with the policy
    pub roles: Option<List>, // List*
    // the policy's condition
    pub qual: Option<Box<Node>>, // Node*
    // the policy's WITH CHECK condition.
    pub with_check: Option<Box<Node>>, // Node*
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterPublicationStmt {
    // Name of of the publication
    pub pubname: Option<String>, // char*
    // List of DefElem nodes
    pub options: Option<Vec<DefElemWrapper>>, // List*
    // List of tables to add/drop
    pub tables: Option<List>, // List*
    // Special publication for all tables in db
    #[serde(default)]
    pub for_all_tables: bool, // bool
    // What action to perform with the tables
    #[serde(rename = "tableAction")]
    pub table_action: Option<DefElemAction>, // DefElemAction
}

// Create/Alter/Drop Role Statements
// Note: these node types are also used for the backwards-compatible
// Create/Alter/Drop User/Group statements.  In the ALTER and DROP cases
// there's really no need to distinguish what the original spelling was,
// but for CREATE we mark the type because the defaults vary.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterRoleSetStmt {
    // role
    pub role: Option<RoleSpecWrapper>, // RoleSpec*
    // database name, or NULL
    pub database: Option<String>, // char*
    // SET or RESET subcommand
    pub setstmt: Option<VariableSetStmtWrapper>, // VariableSetStmt*
}

// Create/Alter/Drop Role Statements
// Note: these node types are also used for the backwards-compatible
// Create/Alter/Drop User/Group statements.  In the ALTER and DROP cases
// there's really no need to distinguish what the original spelling was,
// but for CREATE we mark the type because the defaults vary.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterRoleStmt {
    // role
    pub role: Option<RoleSpecWrapper>, // RoleSpec*
    // List of DefElem nodes
    pub options: Vec<DefElemWrapper>, // List*
    // +1 = add members, -1 = drop members
    pub action: Option<i64>, // int
}

// {Create|Alter} SEQUENCE Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterSeqStmt {
    // the sequence to alter
    pub sequence: Option<RangeVarWrapper>, // RangeVar*
    pub options: Option<List>,             // List*
    #[serde(default)]
    pub for_identity: bool, // bool
    // skip error if a role is missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterSubscriptionStmt {
    // ALTER_SUBSCRIPTION_OPTIONS, etc
    pub kind: AlterSubscriptionType, // AlterSubscriptionType
    // Name of of the subscription
    pub subname: Option<String>, // char*
    // Connection string to publisher
    pub conninfo: Option<String>, // char*
    // One or more publication to subscribe to
    pub publication: Option<List>, // List*
    // List of DefElem nodes
    pub options: Option<Vec<DefElemWrapper>>, // List*
}

// Alter System Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterSystemStmt {
    // SET subcommand
    pub setstmt: Option<VariableSetStmtWrapper>, // VariableSetStmt*
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterTSConfigurationStmt {
    // ALTER_TSCONFIG_ADD_MAPPING, etc
    pub kind: AlterTSConfigType, // AlterTSConfigType
    // qualified name (list of Value strings)
    pub cfgname: Option<Vec<StringStructWrapper>>, // List*
    // list of Value strings
    pub tokentype: Option<Vec<StringStructWrapper>>, // List*
    // list of list of Value strings
    pub dicts: Option<Vec<Vec<StringStructWrapper>>>, // List*
    // if true - remove old variant
    #[serde(default)]
    pub r#override: bool, // bool
    // if true - replace dictionary by another
    #[serde(default)]
    pub replace: bool, // bool
    // for DROP - skip error if missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// TS Dictionary stmts: DefineStmt, RenameStmt and DropStmt are default
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterTSDictionaryStmt {
    // qualified name (list of Value strings)
    pub dictname: Option<Vec<StringStructWrapper>>, // List*
    // List of DefElem nodes
    pub options: Option<Vec<DefElemWrapper>>, // List*
}

// Alter Table
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterTableCmd {
    // Type of table alteration to apply
    pub subtype: Option<AlterTableType>, // AlterTableType
    // column, constraint, or trigger to act on,
    // or tablespace
    pub name: Option<String>,              // char*
    pub newowner: Option<RoleSpecWrapper>, // RoleSpec*
    // definition of new column, index,
    // constraint, or parent table
    pub def: Option<Box<Node>>, // Node*
    // RESTRICT or CASCADE for DROP cases
    pub behavior: Option<DropBehavior>, // DropBehavior
    // skip error if missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterTableMoveAllStmt {
    pub orig_tablespacename: Option<String>, // char*
    // Object type to move
    pub objtype: Option<ObjectType>, // ObjectType
    // List of roles to move objects of
    pub roles: Option<List>,                // List*
    pub new_tablespacename: Option<String>, // char*
    #[serde(default)]
    pub nowait: bool, // bool
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterTableSpaceOptionsStmt {
    pub tablespacename: Option<String>, // char*
    pub options: Option<List>,          // List*
    #[serde(default, rename = "isReset")]
    pub is_reset: bool, // bool
}

// Alter Table
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterTableStmt {
    // table to work on
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // list of subcommands
    pub cmds: Option<List>, // List*
    // type of object
    pub relkind: ObjectType, // ObjectType
    // skip error if table missing
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// Create/Drop USER MAPPING Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlterUserMappingStmt {
    // user role
    pub user: Option<RoleSpecWrapper>, // RoleSpec*
    // server name
    pub servername: Option<String>, // char*
    // generic options to server
    pub options: Option<List>, // List*
}

// AlternativeSubPlan - expression node for a choice among SubPlans
// The subplans are given as a List so that the node definition need not
// change if there's ever more than two alternatives.  For the moment,
// though, there are always exactly two; and the first one is the fast-start
// plan.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct AlternativeSubPlan {
    // SubPlan(s) with equivalent results
    pub subplans: Option<List>, // List*
}

// ArrayCoerceExpr
// ArrayCoerceExpr represents a type coercion from one array type to another,
// which is implemented by applying the indicated element-type coercion
// function to each element of the source array.  If elemfuncid is InvalidOid
// then the element types are binary-compatible, but the coercion still
// requires some effort (we have to fix the element type ID stored in the
// array header).
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ArrayCoerceExpr {
    // input expression (yields an array)
    pub arg: Option<ExprWrapper>, // Expr*
    // OID of element coercion function, or 0
    pub elemfuncid: Option<Oid>, // Oid
    // output type of coercion (an array type)
    pub resulttype: Option<Oid>, // Oid
    // output typmod (also element typmod)
    pub resulttypmod: Option<i32>, // int32
    // OID of collation, or InvalidOid if none
    pub resultcollid: Option<Oid>, // Oid
    // conversion semantics flag to pass to func
    #[serde(default, rename = "isExplicit")]
    pub is_explicit: bool, // bool
    // how to display this node
    pub coerceformat: Option<CoercionForm>, // CoercionForm
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// ArrayExpr - an ARRAY[] expression
// Note: if multidims is false, the constituent expressions all yield the
// scalar type identified by element_typeid.  If multidims is true, the
// constituent expressions all yield arrays of element_typeid (ie, the same
// type as array_typeid); at runtime we must check for compatible subscripts.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ArrayExpr {
    // type of expression result
    pub array_typeid: Option<Oid>, // Oid
    // OID of collation, or InvalidOid if none
    pub array_collid: Option<Oid>, // Oid
    // common type of array elements
    pub element_typeid: Option<Oid>, // Oid
    // the array elements or sub-arrays
    pub elements: Option<List>, // List*
    // true if elements are sub-arrays
    #[serde(default)]
    pub multidims: bool, // bool
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// ArrayRef: describes an array subscripting operation
// An ArrayRef can describe fetching a single element from an array,
// fetching a subarray (array slice), storing a single element into
// an array, or storing a slice.  The "store" cases work with an
// initial array value and a source value that is inserted into the
// appropriate part of the array; the result of the operation is an
// entire new modified array value.
// If reflowerindexpr = NIL, then we are fetching or storing a single array
// element at the subscripts given by refupperindexpr.  Otherwise we are
// fetching or storing an array slice, that is a rectangular subarray
// with lower and upper bounds given by the index expressions.
// reflowerindexpr must be the same length as refupperindexpr when it
// is not NIL.
// In the slice case, individual expressions in the subscript lists can be
// NULL, meaning "substitute the array's current lower or upper bound".
// Note: the result datatype is the element type when fetching a single
// element; but it is the array type when doing subarray fetch or either
// type of store.
// Note: for the cases where an array is returned, if refexpr yields a R/W
// expanded array, then the implementation is allowed to modify that object
// in-place and return the same object.)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ArrayRef {
    // type of the array proper
    pub refarraytype: Option<Oid>, // Oid
    // type of the array elements
    pub refelemtype: Option<Oid>, // Oid
    // typmod of the array (and elements too)
    pub reftypmod: Option<i32>, // int32
    // OID of collation, or InvalidOid if none
    pub refcollid: Option<Oid>, // Oid
    // expressions that evaluate to upper
    // array indexes
    pub refupperindexpr: Option<List>, // List*
    // expressions that evaluate to lower
    // array indexes, or NIL for single array
    // element
    pub reflowerindexpr: Option<List>, // List*
    // the expression that evaluates to an array
    // value
    pub refexpr: Option<ExprWrapper>, // Expr*
    // expression for the source value, or NULL if
    // fetch
    pub refassgnexpr: Option<ExprWrapper>, // Expr*
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct BitString {
    pub str: String, // char*
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct BoolExpr {
    pub boolop: BoolExprType, // BoolExprType
    // arguments to this expression
    pub args: List, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// BooleanTest
// BooleanTest represents the operation of determining whether a boolean
// is TRUE, FALSE, or UNKNOWN (ie, NULL).  All six meaningful combinations
// are supported.  Note that a NULL input does *not* cause a NULL result.
// The appropriate test is performed and returned as a boolean Datum.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct BooleanTest {
    // input expression
    pub arg: Option<ExprWrapper>, // Expr*
    // test type
    pub booltesttype: Option<BoolTestType>, // BoolTestType
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// CaseExpr - a CASE expression
// We support two distinct forms of CASE expression:
// CASE WHEN boolexpr THEN expr [ WHEN boolexpr THEN expr ... ]
// CASE testexpr WHEN compexpr THEN expr [ WHEN compexpr THEN expr ... ]
// These are distinguishable by the "arg" field being NULL in the first case
// and the testexpr in the second case.
// In the raw grammar output for the second form, the condition expressions
// of the WHEN clauses are just the comparison values.  Parse analysis
// converts these to valid boolean expressions of the form
// CaseTestExpr '=' compexpr
// where the CaseTestExpr node is a placeholder that emits the correct
// value at runtime.  This structure is used so that the testexpr need be
// evaluated only once.  Note that after parse analysis, the condition
// expressions always yield boolean.
// Note: we can test whether a CaseExpr has been through parse analysis
// yet by checking whether casetype is InvalidOid or not.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CaseExpr {
    // type of expression result
    pub casetype: Option<Oid>, // Oid
    // OID of collation, or InvalidOid if none
    pub casecollid: Option<Oid>, // Oid
    // implicit equality comparison argument
    pub arg: Option<ExprWrapper>, // Expr*
    // the arguments (list of WHEN clauses)
    pub args: Option<List>, // List*
    // the default result (ELSE clause)
    pub defresult: Option<ExprWrapper>, // Expr*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Placeholder node for the test value to be processed by a CASE expression.
// This is effectively like a Param, but can be implemented more simply
// since we need only one replacement value at a time.
// We also use this in nested UPDATE expressions.
// See transformAssignmentIndirection().
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CaseTestExpr {
    // type for substituted value
    #[serde(rename = "typeId")]
    pub type_id: Option<Oid>, // Oid
    // typemod for substituted value
    #[serde(rename = "typeMod")]
    pub type_mod: Option<i32>, // int32
    // collation for the substituted value
    pub collation: Option<Oid>, // Oid
}

// CaseWhen - one arm of a CASE expression
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CaseWhen {
    // condition expression
    pub expr: Option<ExprWrapper>, // Expr*
    // substitution result
    pub result: Option<ExprWrapper>, // Expr*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Checkpoint Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CheckPointStmt {}

// Close Portal Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ClosePortalStmt {
    // name of the portal (cursor)
    pub portalname: Option<String>, // char*
}

// Cluster Statement (support pbrown's cluster index implementation)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ClusterStmt {
    // relation being indexed, or NULL if all
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // original index defined
    pub indexname: Option<String>, // char*
    // print progress info
    #[serde(default)]
    pub verbose: bool, // bool
}

// CoalesceExpr - a COALESCE expression
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CoalesceExpr {
    // type of expression result
    pub coalescetype: Option<Oid>, // Oid
    // OID of collation, or InvalidOid if none
    pub coalescecollid: Option<Oid>, // Oid
    // the arguments
    pub args: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// CoerceToDomain
// CoerceToDomain represents the operation of coercing a value to a domain
// type.  At runtime (and not before) the precise set of constraints to be
// checked will be determined.  If the value passes, it is returned as the
// result; if not, an error is raised.  Note that this is equivalent to
// RelabelType in the scenario where no constraints are applied.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CoerceToDomain {
    // input expression
    pub arg: Option<ExprWrapper>, // Expr*
    // domain type ID (result type)
    pub resulttype: Option<Oid>, // Oid
    // output typmod (currently always -1)
    pub resulttypmod: Option<i32>, // int32
    // OID of collation, or InvalidOid if none
    pub resultcollid: Option<Oid>, // Oid
    // how to display this node
    pub coercionformat: Option<CoercionForm>, // CoercionForm
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Placeholder node for the value to be processed by a domain's check
// constraint.  This is effectively like a Param, but can be implemented more
// simply since we need only one replacement value at a time.
// Note: the typeId/typeMod/collation will be set from the domain's base type,
// not the domain itself.  This is because we shouldn't consider the value
// to be a member of the domain if we haven't yet checked its constraints.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CoerceToDomainValue {
    // type for substituted value
    #[serde(rename = "typeId")]
    pub type_id: Option<Oid>, // Oid
    // typemod for substituted value
    #[serde(rename = "typeMod")]
    pub type_mod: Option<i32>, // int32
    // collation for the substituted value
    pub collation: Option<Oid>, // Oid
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// CoerceViaIO
// CoerceViaIO represents a type coercion between two types whose textual
// representations are compatible, implemented by invoking the source type's
// typoutput function then the destination type's typinput function.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CoerceViaIO {
    // input expression
    pub arg: Option<ExprWrapper>, // Expr*
    // output type of coercion
    pub resulttype: Option<Oid>, // Oid
    // OID of collation, or InvalidOid if none
    pub resultcollid: Option<Oid>, // Oid
    // how to display this node
    pub coerceformat: Option<CoercionForm>, // CoercionForm
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// CollateClause - a COLLATE expression
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CollateClause {
    // input expression
    pub arg: Option<Box<Node>>, // Node*
    // possibly-qualified collation name
    pub collname: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// CollateExpr - COLLATE
// The planner replaces CollateExpr with RelabelType during expression
// preprocessing, so execution never sees a CollateExpr.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CollateExpr {
    // input expression
    pub arg: Option<ExprWrapper>, // Expr*
    // collation's OID
    #[serde(rename = "collOid")]
    pub coll_oid: Option<Oid>, // Oid
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// ColumnDef - column definition (used in various creates)
// If the column has a default value, we may have the value expression
// in either "raw" form (an untransformed parse tree) or "cooked" form
// (a post-parse-analysis, executable expression tree), depending on
// how this ColumnDef node was created (by parsing, or by inheritance
// from an existing relation).  We should never have both in the same node!
// Similarly, we may have a COLLATE specification in either raw form
// (represented as a CollateClause with arg==NULL) or cooked form
// (the collation's OID).
// The constraints list may contain a CONSTR_DEFAULT item in a raw
// parsetree produced by gram.y, but transformCreateStmt will remove
// the item and set raw_default instead.  CONSTR_DEFAULT items
// should not appear in any subsequent processing.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ColumnDef {
    // name of column
    pub colname: Option<String>, // char*
    // type of column
    #[serde(rename = "typeName")]
    pub type_name: Option<TypeNameWrapper>, // TypeName*
    // number of times column is inherited
    pub inhcount: Option<i64>, // int
    // column has local (non-inherited) def'n
    #[serde(default)]
    pub is_local: bool, // bool
    // NOT NULL constraint specified?
    #[serde(default)]
    pub is_not_null: bool, // bool
    // column definition came from table type
    #[serde(default)]
    pub is_from_type: bool, // bool
    // column def came from partition parent
    #[serde(default)]
    pub is_from_parent: bool, // bool
    // attstorage setting, or 0 for default
    pub storage: Option<char>, // char
    // default value (untransformed parse tree)
    pub raw_default: Option<Box<Node>>, // Node*
    // default value (transformed expr tree)
    pub cooked_default: Option<Box<Node>>, // Node*
    // attidentity setting
    pub identity: Option<char>, // char
    // untransformed COLLATE spec, if any
    #[serde(rename = "collClause")]
    pub coll_clause: Option<CollateClauseWrapper>, // CollateClause*
    // collation OID (InvalidOid if not set)
    #[serde(rename = "collOid")]
    pub coll_oid: Option<Oid>, // Oid
    // other constraints on column
    pub constraints: Option<List>, // List*
    // per-column FDW options
    pub fdwoptions: Option<List>, // List*
    // parse location, or -1 if none/unknown
    pub location: Option<i64>, // int
}

// ColumnRef - specifies a reference to a column, or possibly a whole tuple
// The "fields" list must be nonempty.  It can contain string Value nodes
// (representing names) and A_Star nodes (representing occurrence of a '*').
// Currently, A_Star must appear only as the last list element --- the grammar
// is responsible for enforcing this!
// Note: any array subscripting or selection of fields from composite columns
// is represented by an A_Indirection node above the ColumnRef.  However,
// for simplicity in the normal case, initial field selection from a table
// name is represented within ColumnRef and not by adding A_Indirection.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ColumnRef {
    // field names (Value strings) or A_Star
    pub fields: Vec<ColumnRefField>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Comment On Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CommentStmt {
    // Object's type
    pub objtype: Option<ObjectType>, // ObjectType
    // Qualified name of the object
    pub object: Option<Box<Node>>, // Node*
    // Comment to insert, or NULL to remove
    pub comment: Option<String>, // char*
}

// CommonTableExpr -
// representation of WITH list element
// We don't currently support the SEARCH or CYCLE clause.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CommonTableExpr {
    // query name (never qualified)
    pub ctename: Option<String>, // char*
    // optional list of column names
    pub aliascolnames: Option<List>, // List*
    // the CTE's subquery
    pub ctequery: Option<Box<Node>>, // Node*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
    // is this CTE actually recursive?
    #[serde(default)]
    pub cterecursive: bool, // bool
    // number of RTEs referencing this CTE
    // (excluding internal self-references)
    pub cterefcount: Option<i64>, // int
    // list of output column names
    pub ctecolnames: Option<List>, // List*
    // OID list of output column type OIDs
    pub ctecoltypes: Option<List>, // List*
    // integer list of output column typmods
    pub ctecoltypmods: Option<List>, // List*
    // OID list of column collation OIDs
    pub ctecolcollations: Option<List>, // List*
}

// Create Type Statement, composite types
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CompositeTypeStmt {
    // the composite type to be created
    pub typevar: Option<RangeVarWrapper>, // RangeVar*
    // list of ColumnDef nodes
    pub coldeflist: Vec<ColumnDefWrapper>, // List*
}

// Const
// Note: for varlena data types, we make a rule that a Const node's value
// must be in non-extended form (4-byte header, no compression or external
// references).  This ensures that the Const node is self-contained and makes
// it more likely that equal() will see logically identical values as equal.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Const {
    // pg_type OID of the constant's datatype
    pub consttype: Option<Oid>, // Oid
    // typmod value, if any
    pub consttypmod: Option<i32>, // int32
    // OID of collation, or InvalidOid if none
    pub constcollid: Option<Oid>, // Oid
    // typlen of the constant's datatype
    pub constlen: Option<i64>, // int
    // the constant's value
    pub constvalue: Option<u64>, // Datum
    // whether the constant is null (if true,
    // constvalue is undefined)
    #[serde(default)]
    pub constisnull: bool, // bool
    // whether this datatype is passed by value.
    // If true, then all the information is stored
    // in the Datum. If false, then the Datum
    // contains a pointer to the information.
    #[serde(default)]
    pub constbyval: bool, // bool
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Foreign key matchtype codes
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Constraint {
    // see above
    pub contype: Option<ConstrType>, // ConstrType
    // Constraint name, or NULL if unnamed
    pub conname: Option<String>, // char*
    // DEFERRABLE?
    #[serde(default)]
    pub deferrable: bool, // bool
    // INITIALLY DEFERRED?
    #[serde(default)]
    pub initdeferred: bool, // bool
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
    // is constraint non-inheritable?
    #[serde(default)]
    pub is_no_inherit: bool, // bool
    // expr, as untransformed parse tree
    pub raw_expr: Option<Box<Node>>, // Node*
    // expr, as nodeToString representation
    pub cooked_expr: Option<String>,  // char*
    pub generated_when: Option<char>, // char
    // String nodes naming referenced column(s)
    pub keys: Option<List>, // List*
    // list of (IndexElem, operator name) pairs
    pub exclusions: Option<List>, // List*
    // options from WITH clause
    pub options: Option<List>, // List*
    // existing index to use; otherwise NULL
    pub indexname: Option<String>, // char*
    // index tablespace; NULL for default
    pub indexspace: Option<String>, // char*
    // index access method; NULL for default
    pub access_method: Option<String>, // char*
    // partial index predicate
    pub where_clause: Option<Box<Node>>, // Node*
    // Primary key table
    pub pktable: Option<RangeVarWrapper>, // RangeVar*
    // Attributes of foreign key
    pub fk_attrs: Option<List>, // List*
    // Corresponding attrs in PK table
    pub pk_attrs: Option<List>, // List*
    // FULL, PARTIAL, SIMPLE
    pub fk_matchtype: Option<char>, // char
    // ON UPDATE action
    pub fk_upd_action: Option<char>, // char
    // ON DELETE action
    pub fk_del_action: Option<char>, // char
    // pg_constraint.conpfeqop of my former self
    pub old_conpfeqop: Option<List>, // List*
    // pg_constraint.confrelid of my former
    // self
    pub old_pktable_oid: Option<Oid>, // Oid
    // skip validation of existing rows?
    #[serde(default)]
    pub skip_validation: bool, // bool
    // mark the new constraint as valid?
    #[serde(default)]
    pub initially_valid: bool, // bool
}

// SET CONSTRAINTS Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ConstraintsSetStmt {
    // List of names as RangeVars
    pub constraints: Option<List>, // List*
    #[serde(default)]
    pub deferred: bool, // bool
}

// ConvertRowtypeExpr
// ConvertRowtypeExpr represents a type coercion from one composite type
// to another, where the source type is guaranteed to contain all the columns
// needed for the destination type plus possibly others; the columns need not
// be in the same positions, but are matched up by name.  This is primarily
// used to convert a whole-row value of an inheritance child table into a
// valid whole-row value of its parent table's rowtype.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ConvertRowtypeExpr {
    // input expression
    pub arg: Option<ExprWrapper>, // Expr*
    // output type (always a composite type)
    pub resulttype: Option<Oid>, // Oid
    // how to display this node
    pub convertformat: Option<CoercionForm>, // CoercionForm
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Copy Statement
// We support "COPY relation FROM file", "COPY relation TO file", and
// "COPY (query) TO file".  In any given CopyStmt, exactly one of "relation"
// and "query" must be non-NULL.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CopyStmt {
    // the relation to copy
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // the query (SELECT or DML statement with
    // RETURNING) to copy, as a raw parse tree
    pub query: Option<Box<Node>>, // Node*
    // List of column names (as Strings), or NIL
    // for all columns
    pub attlist: Option<List>, // List*
    // TO or FROM
    #[serde(default)]
    pub is_from: bool, // bool
    // is 'filename' a program to popen?
    #[serde(default)]
    pub is_program: bool, // bool
    // filename, or NULL for STDIN/STDOUT
    pub filename: Option<String>, // char*
    // List of DefElem nodes
    pub options: Vec<DefElemWrapper>, // List*
}

// Create ACCESS METHOD Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateAmStmt {
    // access method name
    pub amname: Option<String>, // char*
    // handler function name
    pub handler_name: Option<List>, // List*
    // type of access method
    pub amtype: Option<char>, // char
}

// CREATE CAST Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateCastStmt {
    pub sourcetype: Option<TypeNameWrapper>, // TypeName*
    pub targettype: Option<TypeNameWrapper>, // TypeName*
    pub func: Option<ObjectWithArgsWrapper>, // ObjectWithArgs*
    pub context: Option<CoercionContext>,    // CoercionContext
    #[serde(default)]
    pub inout: bool,   // bool
}

// CREATE CONVERSION Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateConversionStmt {
    // Name of the conversion
    pub conversion_name: Option<List>, // List*
    // source encoding name
    pub for_encoding_name: Option<String>, // char*
    // destination encoding name
    pub to_encoding_name: Option<String>, // char*
    // qualified conversion function name
    pub func_name: Option<List>, // List*
    // is this a default conversion?
    #[serde(default)]
    pub def: bool, // bool
}

// Create Domain Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateDomainStmt {
    // qualified name (list of Value strings)
    pub domainname: Vec<StringStructWrapper>, // List*
    // the base type
    #[serde(rename = "typeName")]
    pub type_name: Option<TypeNameWrapper>, // TypeName*
    // untransformed COLLATE spec, if any
    #[serde(rename = "collClause")]
    pub coll_clause: Option<CollateClauseWrapper>, // CollateClause*
    // constraints (list of Constraint nodes)
    pub constraints: Vec<ConstraintWrapper>, // List*
}

// Create Type Statement, enum types
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateEnumStmt {
    // qualified name (list of Value strings)
    #[serde(rename = "typeName")]
    pub type_name: Vec<StringStructWrapper>, // List*
    // enum values (list of Value strings)
    pub vals: Vec<StringStructWrapper>, // List*
}

// Create EVENT TRIGGER Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateEventTrigStmt {
    // TRIGGER's name
    pub trigname: Option<String>, // char*
    // event's identifier
    pub eventname: Option<String>, // char*
    // list of DefElems indicating filtering
    pub whenclause: Option<List>, // List*
    // qual. name of function to call
    pub funcname: Option<List>, // List*
}

// Create/Alter Extension Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateExtensionStmt {
    pub extname: Option<String>, // char*
    // just do nothing if it already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
    // List of DefElem nodes
    pub options: Vec<DefElemWrapper>, // List*
}

// Create/Alter FOREIGN DATA WRAPPER Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateFdwStmt {
    // foreign-data wrapper name
    pub fdwname: Option<String>, // char*
    // HANDLER/VALIDATOR options
    pub func_options: Option<List>, // List*
    // generic options to FDW
    pub options: Option<List>, // List*
}

// Create/Alter FOREIGN SERVER Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateForeignServerStmt {
    // server name
    pub servername: Option<String>, // char*
    // optional server type
    pub servertype: Option<String>, // char*
    // optional server version
    pub version: Option<String>, // char*
    // FDW name
    pub fdwname: Option<String>, // char*
    // just do nothing if it already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
    // generic options to server
    pub options: Option<List>, // List*
}

// Create FOREIGN TABLE Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateForeignTableStmt {
    pub base: Option<CreateStmtWrapper>, // CreateStmt
    pub servername: Option<String>,      // char*
    pub options: Option<List>,           // List*
}

// Create Function Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateFunctionStmt {
    // T => replace if already exists
    #[serde(default)]
    pub replace: bool, // bool
    // qualified name of function to create
    pub funcname: List, // List*
    // a list of FunctionParameter
    pub parameters: Option<Vec<FunctionParameterWrapper>>, // List*
    // the return type
    #[serde(rename = "returnType")]
    pub return_type: TypeNameWrapper, // TypeName*
    // a list of DefElem
    pub options: Vec<DefElemWrapper>, // List*
    // a list of DefElem
    #[serde(rename = "withClause")]
    pub with_clause: Option<Vec<DefElemWrapper>>, // List*
}

// Create Operator Class Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateOpClassItem {
    // see codes above
    pub itemtype: Option<i64>, // int
    // operator or function name and args
    pub name: Option<ObjectWithArgsWrapper>, // ObjectWithArgs*
    // strategy num or support proc num
    pub number: Option<i64>, // int
    // only used for ordering operators
    pub order_family: Option<List>, // List*
    // amproclefttype/amprocrighttype or
    // amoplefttype/amoprighttype
    pub class_args: Option<List>, // List*
    // datatype stored in index
    pub storedtype: Option<TypeNameWrapper>, // TypeName*
}

// Create Operator Class Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateOpClassStmt {
    // qualified name (list of Value strings)
    pub opclassname: Option<Vec<StringStructWrapper>>, // List*
    // qualified name (ditto); NIL if omitted
    pub opfamilyname: Option<List>, // List*
    // name of index AM opclass is for
    pub amname: Option<String>, // char*
    // datatype of indexed column
    pub datatype: Option<TypeNameWrapper>, // TypeName*
    // List of CreateOpClassItem nodes
    pub items: Option<Vec<CreateOpClassItemWrapper>>, // List*
    // Should be marked as default for type?
    #[serde(default, rename = "isDefault")]
    pub is_default: bool, // bool
}

// Create Operator Family Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateOpFamilyStmt {
    // qualified name (list of Value strings)
    pub opfamilyname: Option<Vec<StringStructWrapper>>, // List*
    // name of index AM opfamily is for
    pub amname: Option<String>, // char*
}

// Create/Drop PROCEDURAL LANGUAGE Statements
// Create PROCEDURAL LANGUAGE Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreatePLangStmt {
    // T => replace if already exists
    #[serde(default)]
    pub replace: bool, // bool
    // PL name
    pub plname: Option<String>, // char*
    // PL call handler function (qual. name)
    pub plhandler: Option<List>, // List*
    // optional inline function (qual. name)
    pub plinline: Option<List>, // List*
    // optional validator function (qual. name)
    pub plvalidator: Option<List>, // List*
    // PL is trusted
    #[serde(default)]
    pub pltrusted: bool, // bool
}

// Create POLICY Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreatePolicyStmt {
    // Policy's name
    pub policy_name: Option<String>, // char*
    // the table name the policy applies to
    pub table: Option<RangeVarWrapper>, // RangeVar*
    // the command name the policy applies to
    pub cmd_name: Option<String>, // char*
    // restrictive or permissive policy
    #[serde(default)]
    pub permissive: bool, // bool
    // the roles associated with the policy
    pub roles: Option<List>, // List*
    // the policy's condition
    pub qual: Option<Box<Node>>, // Node*
    // the policy's WITH CHECK condition.
    pub with_check: Option<Box<Node>>, // Node*
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreatePublicationStmt {
    // Name of of the publication
    pub pubname: Option<String>, // char*
    // List of DefElem nodes
    pub options: Option<Vec<DefElemWrapper>>, // List*
    // Optional list of tables to add
    pub tables: Option<List>, // List*
    // Special publication for all tables in db
    #[serde(default)]
    pub for_all_tables: bool, // bool
}

// Create Type Statement, range types
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateRangeStmt {
    // qualified name (list of Value strings)
    #[serde(rename = "typeName")]
    pub type_name: Option<Vec<StringStructWrapper>>, // List*
    // range parameters (list of DefElem)
    pub params: Option<Vec<DefElemWrapper>>, // List*
}

// Create/Alter/Drop Role Statements
// Note: these node types are also used for the backwards-compatible
// Create/Alter/Drop User/Group statements.  In the ALTER and DROP cases
// there's really no need to distinguish what the original spelling was,
// but for CREATE we mark the type because the defaults vary.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateRoleStmt {
    // ROLE/USER/GROUP
    pub stmt_type: Option<RoleStmtType>, // RoleStmtType
    // role name
    pub role: Option<String>, // char*
    // List of DefElem nodes
    pub options: Option<Vec<DefElemWrapper>>, // List*
}

// Create Schema Statement
// NOTE: the schemaElts list contains raw parsetrees for component statements
// of the schema, such as CREATE TABLE, GRANT, etc.  These are analyzed and
// executed after the schema itself is created.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateSchemaStmt {
    // the name of the schema to create
    pub schemaname: Option<String>, // char*
    // the owner of the created schema
    pub authrole: Option<RoleSpecWrapper>, // RoleSpec*
    // schema components (list of parsenodes)
    #[serde(rename = "schemaElts")]
    pub schema_elts: Option<List>, // List*
    // just do nothing if schema already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
}

// {Create|Alter} SEQUENCE Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateSeqStmt {
    // the sequence to create
    pub sequence: Option<RangeVarWrapper>, // RangeVar*
    pub options: Option<List>,             // List*
    // ID of owner, or InvalidOid for default
    #[serde(rename = "ownerId")]
    pub owner_id: Option<Oid>, // Oid
    #[serde(default)]
    pub for_identity: bool, // bool
    // just do nothing if it already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
}

// Create Statistics Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateStatsStmt {
    // qualified name (list of Value strings)
    pub defnames: Option<Vec<StringStructWrapper>>, // List*
    // stat types (list of Value strings)
    pub stat_types: Option<Vec<StringStructWrapper>>, // List*
    // expressions to build statistics on
    pub exprs: Option<List>, // List*
    // rels to build stats on (list of RangeVar)
    pub relations: Option<Vec<RangeVarWrapper>>, // List*
    // do nothing if stats name already exists
    #[serde(default)]
    pub if_not_exists: bool, // bool
}

// Create Table Statement
// NOTE: in the raw gram.y output, ColumnDef and Constraint nodes are
// intermixed in tableElts, and constraints is NIL.  After parse analysis,
// tableElts contains just ColumnDefs, and constraints contains just
// Constraint nodes (in fact, only CONSTR_CHECK nodes, in the present
// implementation).
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateStmt {
    // relation to create
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // column definitions (list of ColumnDef)
    #[serde(rename = "tableElts")]
    pub table_elts: Option<Vec<ColumnDefWrapper>>, // List*
    // relations to inherit from (list of
    // inhRelation)
    #[serde(rename = "inhRelations")]
    pub inh_relations: Option<List>, // List*
    // FOR VALUES clause
    pub partbound: Option<PartitionBoundSpecWrapper>, // PartitionBoundSpec*
    // PARTITION BY clause
    pub partspec: Option<PartitionSpecWrapper>, // PartitionSpec*
    // OF typename
    #[serde(rename = "ofTypename")]
    pub of_typename: Option<TypeNameWrapper>, // TypeName*
    // constraints (list of Constraint nodes)
    pub constraints: Option<Vec<ConstraintWrapper>>, // List*
    // options from WITH clause
    pub options: Option<List>, // List*
    // what do we do at COMMIT?
    pub oncommit: Option<OnCommitAction>, // OnCommitAction
    // table space to use, or NULL
    pub tablespacename: Option<String>, // char*
    // just do nothing if it already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateSubscriptionStmt {
    // Name of of the subscription
    pub subname: Option<String>, // char*
    // Connection string to publisher
    pub conninfo: Option<String>, // char*
    // One or more publication to subscribe to
    pub publication: Option<List>, // List*
    // List of DefElem nodes
    pub options: Option<Vec<DefElemWrapper>>, // List*
}

// CREATE TABLE AS Statement (a/k/a SELECT INTO)
// A query written as CREATE TABLE AS will produce this node type natively.
// A query written as SELECT ... INTO will be transformed to this form during
// parse analysis.
// A query written as CREATE MATERIALIZED view will produce this node type,
// during parse analysis, since it needs all the same data.
// The "query" field is handled similarly to EXPLAIN, though note that it
// can be a SELECT or an EXECUTE, but not other DML statements.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateTableAsStmt {
    // the query (see comments above)
    pub query: Option<Box<Node>>, // Node*
    // destination table
    pub into: Option<IntoClauseWrapper>, // IntoClause*
    // OBJECT_TABLE or OBJECT_MATVIEW
    pub relkind: ObjectType, // ObjectType
    // it was written as SELECT INTO
    #[serde(default)]
    pub is_select_into: bool, // bool
    // just do nothing if it already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
}

// Create/Drop Table Space Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateTableSpaceStmt {
    pub tablespacename: Option<String>, // char*
    pub owner: Option<RoleSpecWrapper>, // RoleSpec*
    pub location: Option<String>,       // char*
    pub options: Option<List>,          // List*
}

// CREATE TRANSFORM Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateTransformStmt {
    #[serde(default)]
    pub replace: bool, // bool
    pub type_name: Option<TypeNameWrapper>,     // TypeName*
    pub lang: Option<String>,                   // char*
    pub fromsql: Option<ObjectWithArgsWrapper>, // ObjectWithArgs*
    pub tosql: Option<ObjectWithArgsWrapper>,   // ObjectWithArgs*
}

// Create TRIGGER Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateTrigStmt {
    // TRIGGER's name
    pub trigname: Option<String>, // char*
    // relation trigger is on
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // qual. name of function to call
    pub funcname: Option<List>, // List*
    // list of (T_String) Values or NIL
    pub args: Option<List>, // List*
    // ROW/STATEMENT
    #[serde(default)]
    pub row: bool, // bool
    // BEFORE, AFTER, or INSTEAD
    pub timing: Option<i16>, // int16
    // "OR" of INSERT/UPDATE/DELETE/TRUNCATE
    pub events: Option<i16>, // int16
    // column names, or NIL for all columns
    pub columns: Option<List>, // List*
    // qual expression, or NULL if none
    #[serde(rename = "whenClause")]
    pub when_clause: Option<Box<Node>>, // Node*
    // This is a constraint trigger
    #[serde(default)]
    pub isconstraint: bool, // bool
    // TriggerTransition nodes, or NIL if none
    #[serde(rename = "transitionRels")]
    pub transition_rels: Option<List>, // List*
    // [NOT] DEFERRABLE
    #[serde(default)]
    pub deferrable: bool, // bool
    // INITIALLY {DEFERRED|IMMEDIATE}
    #[serde(default)]
    pub initdeferred: bool, // bool
    // opposite relation, if RI trigger
    pub constrrel: Option<RangeVarWrapper>, // RangeVar*
}

// Create/Drop USER MAPPING Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreateUserMappingStmt {
    // user role
    pub user: Option<RoleSpecWrapper>, // RoleSpec*
    // server name
    pub servername: Option<String>, // char*
    // just do nothing if it already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
    // generic options to server
    pub options: Option<List>, // List*
}

// Createdb Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CreatedbStmt {
    // name of database to create
    pub dbname: Option<String>, // char*
    // List of DefElem nodes
    pub options: Option<Vec<DefElemWrapper>>, // List*
}

// Node representing [WHERE] CURRENT OF cursor_name
// CURRENT OF is a bit like a Var, in that it carries the rangetable index
// of the target relation being constrained; this aids placing the expression
// correctly during planning.  We can assume however that its "levelsup" is
// always zero, due to the syntactic constraints on where it can appear.
// The referenced cursor can be represented either as a hardwired string
// or as a reference to a run-time parameter of type REFCURSOR.  The latter
// case is for the convenience of plpgsql.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct CurrentOfExpr {
    // RT index of target relation
    pub cvarno: Option<Index>, // Index
    // name of referenced cursor, or NULL
    pub cursor_name: Option<String>, // char*
    // refcursor parameter number, or 0
    pub cursor_param: Option<i64>, // int
}

// DEALLOCATE Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DeallocateStmt {
    // The name of the plan to remove
    pub name: Option<String>, // char*
}

// these planner-control flags do not correspond to any SQL grammar:
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DeclareCursorStmt {
    // name of the portal (cursor)
    pub portalname: Option<String>, // char*
    // bitmask of options (see above)
    pub options: Option<i64>, // int
    // the query (see comments above)
    pub query: Option<Box<Node>>, // Node*
}

// DefElem - a generic "name = value" option definition
// In some contexts the name can be qualified.  Also, certain SQL commands
// allow a SET/ADD/DROP action to be attached to option settings, so it's
// convenient to carry a field for that too.  (Note: currently, it is our
// practice that the grammar allows namespace and action only in statements
// where they are relevant; C code can just ignore those fields in other
// statements.)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DefElem {
    // NULL if unqualified name
    pub defnamespace: Option<String>, // char*
    pub defname: Option<String>,      // char*
    // a (Value *) or a (TypeName *)
    pub arg: DefElemArgs, // Node*
    // unspecified action, or SET/ADD/DROP
    pub defaction: Option<DefElemAction>, // DefElemAction
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Create {Aggregate|Operator|Type} Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DefineStmt {
    // aggregate, operator, type
    pub kind: ObjectType, // ObjectType
    // hack to signal old CREATE AGG syntax
    #[serde(default)]
    pub oldstyle: bool, // bool
    // qualified name (list of Value strings)
    pub defnames: Option<Vec<StringStructWrapper>>, // List*
    // a list of TypeName (if needed)
    pub args: Option<Vec<TypeNameWrapper>>, // List*
    // a list of DefElem
    pub definition: Option<Vec<DefElemWrapper>>, // List*
    // just do nothing if it already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
}

// Delete Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DeleteStmt {
    // relation to delete from
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // optional using clause for more tables
    #[serde(rename = "usingClause")]
    pub using_clause: Option<List>, // List*
    // qualifications
    #[serde(rename = "whereClause")]
    pub where_clause: Option<Box<Node>>, // Node*
    // list of expressions to return
    #[serde(rename = "returningList")]
    pub returning_list: Option<List>, // List*
    // WITH clause
    #[serde(rename = "withClause")]
    pub with_clause: Option<WithClauseWrapper>, // WithClause*
}

// Discard Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DiscardStmt {
    pub target: Option<DiscardMode>, // DiscardMode
}

// DO Statement
// DoStmt is the raw parser output, InlineCodeBlock is the execution-time API
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DoStmt {
    // List of DefElem nodes
    pub args: Option<Vec<DefElemWrapper>>, // List*
}

// DROP OWNED statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DropOwnedStmt {
    pub roles: Option<List>,            // List*
    pub behavior: Option<DropBehavior>, // DropBehavior
}

// Create/Alter/Drop Role Statements
// Note: these node types are also used for the backwards-compatible
// Create/Alter/Drop User/Group statements.  In the ALTER and DROP cases
// there's really no need to distinguish what the original spelling was,
// but for CREATE we mark the type because the defaults vary.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DropRoleStmt {
    // List of roles to remove
    pub roles: Option<List>, // List*
    // skip error if a role is missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// Drop Table|Sequence|View|Index|Type|Domain|Conversion|Schema Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DropStmt {
    // list of names
    pub objects: Option<List>, // List*
    // object type
    #[serde(rename = "removeType")]
    pub remove_type: Option<ObjectType>, // ObjectType
    // RESTRICT or CASCADE behavior
    pub behavior: Option<DropBehavior>, // DropBehavior
    // skip error if object is missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
    // drop index concurrently?
    #[serde(default)]
    pub concurrent: bool, // bool
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DropSubscriptionStmt {
    // Name of of the subscription
    pub subname: Option<String>, // char*
    // Skip error if missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
    // RESTRICT or CASCADE behavior
    pub behavior: Option<DropBehavior>, // DropBehavior
}

// Create/Drop Table Space Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DropTableSpaceStmt {
    pub tablespacename: Option<String>, // char*
    // skip error if missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// Create/Drop USER MAPPING Statements
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DropUserMappingStmt {
    // user role
    pub user: Option<RoleSpecWrapper>, // RoleSpec*
    // server name
    pub servername: Option<String>, // char*
    // ignore missing mappings
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// Dropdb Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct DropdbStmt {
    // database to drop
    pub dbname: Option<String>, // char*
    // skip error if db is missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// EXECUTE Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ExecuteStmt {
    // The name of the plan to execute
    pub name: Option<String>, // char*
    // Values to assign to parameters
    pub params: Option<List>, // List*
}

// Explain Statement
// The "query" field is initially a raw parse tree, and is converted to a
// Query node during parse analysis.  Note that rewriting and planning
// of the query are always postponed until execution.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ExplainStmt {
    // the query (see comments above)
    pub query: Option<Box<Node>>, // Node*
    // list of DefElem nodes
    pub options: Option<Vec<DefElemWrapper>>, // List*
}

// Expr - generic superclass for executable-expression nodes
// All node types that are used in executable expression trees should derive
// from Expr (that is, have Expr as their first field).  Since Expr only
// contains NodeTag, this is a formality, but it is an easy form of
// documentation.  See also the ExprState node types in execnodes.h.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Expr {}

// Fetch Statement (also Move)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct FetchStmt {
    // see above
    pub direction: Option<FetchDirection>, // FetchDirection
    // number of rows, or position argument
    #[serde(rename = "howMany")]
    pub how_many: Option<i64>, // long
    // name of portal (cursor)
    pub portalname: Option<String>, // char*
    // TRUE if MOVE
    #[serde(default)]
    pub ismove: bool, // bool
}

// FieldSelect
// FieldSelect represents the operation of extracting one field from a tuple
// value.  At runtime, the input expression is expected to yield a rowtype
// Datum.  The specified field number is extracted and returned as a Datum.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct FieldSelect {
    // input expression
    pub arg: Option<ExprWrapper>, // Expr*
    // attribute number of field to extract
    pub fieldnum: Option<AttrNumber>, // AttrNumber
    // type of the field (result type of this
    // node)
    pub resulttype: Option<Oid>, // Oid
    // output typmod (usually -1)
    pub resulttypmod: Option<i32>, // int32
    // OID of collation of the field
    pub resultcollid: Option<Oid>, // Oid
}

// FieldStore
// FieldStore represents the operation of modifying one field in a tuple
// value, yielding a new tuple value (the input is not touched!).  Like
// the assign case of ArrayRef, this is used to implement UPDATE of a
// portion of a column.
// A single FieldStore can actually represent updates of several different
// fields.  The parser only generates FieldStores with single-element lists,
// but the planner will collapse multiple updates of the same base column
// into one FieldStore.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct FieldStore {
    // input tuple value
    pub arg: Option<ExprWrapper>, // Expr*
    // new value(s) for field(s)
    pub newvals: Option<List>, // List*
    // integer list of field attnums
    pub fieldnums: Option<List>, // List*
    // type of result (same as type of arg)
    pub resulttype: Option<Oid>, // Oid
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Float {
    pub str: String, // char*
}

// FromExpr - represents a FROM ... WHERE ... construct
// This is both more flexible than a JoinExpr (it can have any number of
// children, including zero) and less so --- we don't need to deal with
// aliases and so on.  The output column set is implicitly just the union
// of the outputs of the children.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct FromExpr {
    // List of join subtrees
    pub fromlist: Option<List>, // List*
    // qualifiers on join, if any
    pub quals: Option<Box<Node>>, // Node*
}

// FuncCall - a function or aggregate invocation
// agg_order (if not NIL) indicates we saw 'foo(... ORDER BY ...)', or if
// agg_within_group is true, it was 'foo(...) WITHIN GROUP (ORDER BY ...)'.
// agg_star indicates we saw a 'foo(*)' construct, while agg_distinct
// indicates we saw 'foo(DISTINCT ...)'.  In any of these cases, the
// construct *must* be an aggregate call.  Otherwise, it might be either an
// aggregate or some other kind of function.  However, if FILTER or OVER is
// present it had better be an aggregate or window function.
// Normally, you'd initialize this via makeFuncCall() and then only change the
// parts of the struct its defaults don't match afterwards, as needed.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct FuncCall {
    // qualified name of function
    pub funcname: List, // List*
    // the arguments (list of exprs)
    pub args: Option<List>, // List*
    // ORDER BY (list of SortBy)
    pub agg_order: Option<Vec<SortByWrapper>>, // List*
    // FILTER clause, if any
    pub agg_filter: Option<Box<Node>>, // Node*
    // ORDER BY appeared in WITHIN GROUP
    #[serde(default)]
    pub agg_within_group: bool, // bool
    // argument was really '*'
    #[serde(default)]
    pub agg_star: bool, // bool
    // arguments were labeled DISTINCT
    #[serde(default)]
    pub agg_distinct: bool, // bool
    // last argument was labeled VARIADIC
    #[serde(default)]
    pub func_variadic: bool, // bool
    // OVER clause, if any
    pub over: Option<WindowDefWrapper>, // WindowDef*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// FuncExpr - expression node for a function call
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct FuncExpr {
    // PG_PROC OID of the function
    pub funcid: Option<Oid>, // Oid
    // PG_TYPE OID of result value
    pub funcresulttype: Option<Oid>, // Oid
    // true if function returns set
    #[serde(default)]
    pub funcretset: bool, // bool
    // true if variadic arguments have been
    // combined into an array last argument
    #[serde(default)]
    pub funcvariadic: bool, // bool
    // how to display this function call
    pub funcformat: Option<CoercionForm>, // CoercionForm
    // OID of collation of result
    pub funccollid: Option<Oid>, // Oid
    // OID of collation that function should use
    pub inputcollid: Option<Oid>, // Oid
    // arguments to the function
    pub args: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Create Function Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct FunctionParameter {
    // parameter name, or NULL if not given
    pub name: Option<String>, // char*
    // TypeName for parameter type
    #[serde(rename = "argType")]
    pub arg_type: TypeNameWrapper, // TypeName*
    // IN/OUT/etc
    pub mode: Option<FunctionParameterMode>, // FunctionParameterMode
    // raw default expr, or NULL if not given
    pub defexpr: Option<Box<Node>>, // Node*
}

// Grant/Revoke Role Statement
// Note: because of the parsing ambiguity with the GRANT <privileges>
// statement, granted_roles is a list of AccessPriv; the execution code
// should complain if any column lists appear.  grantee_roles is a list
// of role names, as Value strings.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct GrantRoleStmt {
    // list of roles to be granted/revoked
    pub granted_roles: Option<List>, // List*
    // list of member roles to add/delete
    pub grantee_roles: Option<List>, // List*
    // true = GRANT, false = REVOKE
    #[serde(default)]
    pub is_grant: bool, // bool
    // with admin option
    #[serde(default)]
    pub admin_opt: bool, // bool
    // set grantor to other than current role
    pub grantor: Option<RoleSpecWrapper>, // RoleSpec*
    // drop behavior (for REVOKE)
    pub behavior: Option<DropBehavior>, // DropBehavior
}

// Grant|Revoke Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct GrantStmt {
    // true = GRANT, false = REVOKE
    #[serde(default)]
    pub is_grant: bool, // bool
    // type of the grant target
    pub targtype: Option<GrantTargetType>, // GrantTargetType
    // kind of object being operated on
    pub objtype: Option<GrantObjectType>, // GrantObjectType
    // list of RangeVar nodes, ObjectWithArgs
    // nodes, or plain names (as Value strings)
    pub objects: Option<Vec<RangeVarWrapper>>, // List*
    // list of AccessPriv nodes
    pub privileges: Option<Vec<AccessPrivWrapper>>, // List*
    // list of RoleSpec nodes
    pub grantees: Option<Vec<RoleSpecWrapper>>, // List*
    // grant or revoke grant option
    #[serde(default)]
    pub grant_option: bool, // bool
    // drop behavior (for REVOKE)
    pub behavior: Option<DropBehavior>, // DropBehavior
}

// GroupingFunc
// A GroupingFunc is a GROUPING(...) expression, which behaves in many ways
// like an aggregate function (e.g. it "belongs" to a specific query level,
// which might not be the one immediately containing it), but also differs in
// an important respect: it never evaluates its arguments, they merely
// designate expressions from the GROUP BY clause of the query level to which
// it belongs.
// The spec defines the evaluation of GROUPING() purely by syntactic
// replacement, but we make it a real expression for optimization purposes so
// that one Agg node can handle multiple grouping sets at once.  Evaluating the
// result only needs the column positions to check against the grouping set
// being projected.  However, for EXPLAIN to produce meaningful output, we have
// to keep the original expressions around, since expression deparse does not
// give us any feasible way to get at the GROUP BY clause.
// Also, we treat two GroupingFunc nodes as equal if they have equal arguments
// lists and agglevelsup, without comparing the refs and cols annotations.
// In raw parse output we have only the args list; parse analysis fills in the
// refs list, and the planner fills in the cols list.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct GroupingFunc {
    // arguments, not evaluated but kept for
    // benefit of EXPLAIN etc.
    pub args: Option<List>, // List*
    // ressortgrouprefs of arguments
    pub refs: Option<List>, // List*
    // actual column positions set by planner
    pub cols: Option<List>, // List*
    // same as Aggref.agglevelsup
    pub agglevelsup: Option<Index>, // Index
    // token location
    pub location: Option<i64>, // int
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct GroupingSet {
    pub kind: GroupingSetKind, // GroupingSetKind
    pub content: Option<List>, // List*
    pub location: Option<i64>, // int
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ImportForeignSchemaStmt {
    // FDW server name
    pub server_name: Option<String>, // char*
    // remote schema name to query
    pub remote_schema: Option<String>, // char*
    // local schema to create objects in
    pub local_schema: Option<String>, // char*
    // type of table list
    pub list_type: Option<ImportForeignSchemaType>, // ImportForeignSchemaType
    // List of RangeVar
    pub table_list: Option<Vec<RangeVarWrapper>>, // List*
    // list of options to pass to FDW
    pub options: Option<List>, // List*
}

// IndexElem - index parameters (used in CREATE INDEX, and in ON CONFLICT)
// For a plain index attribute, 'name' is the name of the table column to
// index, and 'expr' is NULL.  For an index expression, 'name' is NULL and
// 'expr' is the expression tree.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct IndexElem {
    // name of attribute to index, or NULL
    pub name: Option<String>, // char*
    // expression to index, or NULL
    pub expr: Option<Box<Node>>, // Node*
    // name for index column; NULL = default
    pub indexcolname: Option<String>, // char*
    // name of collation; NIL = default
    pub collation: Option<List>, // List*
    // name of desired opclass; NIL = default
    pub opclass: Option<List>, // List*
    // ASC/DESC/default
    pub ordering: Option<SortByDir>, // SortByDir
    // FIRST/LAST/default
    pub nulls_ordering: Option<SortByNulls>, // SortByNulls
}

// Create Index Statement
// This represents creation of an index and/or an associated constraint.
// If isconstraint is true, we should create a pg_constraint entry along
// with the index.  But if indexOid isn't InvalidOid, we are not creating an
// index, just a UNIQUE/PKEY constraint using an existing index.  isconstraint
// must always be true in this case, and the fields describing the index
// properties are empty.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct IndexStmt {
    // name of new index, or NULL for default
    pub idxname: Option<String>, // char*
    // relation to build index on
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // name of access method (eg. btree)
    #[serde(rename = "accessMethod")]
    pub access_method: Option<String>, // char*
    // tablespace, or NULL for default
    #[serde(rename = "tableSpace")]
    pub table_space: Option<String>, // char*
    // columns to index: a list of IndexElem
    #[serde(rename = "indexParams")]
    pub index_params: Option<Vec<IndexElemWrapper>>, // List*
    // WITH clause options: a list of DefElem
    pub options: Option<Vec<DefElemWrapper>>, // List*
    // qualification (partial-index predicate)
    #[serde(rename = "whereClause")]
    pub where_clause: Option<Box<Node>>, // Node*
    // exclusion operator names, or NIL if none
    #[serde(rename = "excludeOpNames")]
    pub exclude_op_names: Option<List>, // List*
    // comment to apply to index, or NULL
    pub idxcomment: Option<String>, // char*
    // OID of an existing index, if any
    #[serde(rename = "indexOid")]
    pub index_oid: Option<Oid>, // Oid
    // relfilenode of existing storage, if any
    #[serde(rename = "oldNode")]
    pub old_node: Option<Oid>, // Oid
    // is index unique?
    #[serde(default)]
    pub unique: bool, // bool
    // is index a primary key?
    #[serde(default)]
    pub primary: bool, // bool
    // is it for a pkey/unique constraint?
    #[serde(default)]
    pub isconstraint: bool, // bool
    // is the constraint DEFERRABLE?
    #[serde(default)]
    pub deferrable: bool, // bool
    // is the constraint INITIALLY DEFERRED?
    #[serde(default)]
    pub initdeferred: bool, // bool
    // true when transformIndexStmt is finished
    #[serde(default)]
    pub transformed: bool, // bool
    // should this be a concurrent index build?
    #[serde(default)]
    pub concurrent: bool, // bool
    // just do nothing if index already exists?
    #[serde(default)]
    pub if_not_exists: bool, // bool
}

// InferClause -
// ON CONFLICT unique index inference clause
// Note: InferClause does not propagate into the Query representation.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct InferClause {
    // IndexElems to infer unique index
    #[serde(rename = "indexElems")]
    pub index_elems: Option<List>, // List*
    // qualification (partial-index predicate)
    #[serde(rename = "whereClause")]
    pub where_clause: Option<Box<Node>>, // Node*
    // Constraint name, or NULL if unnamed
    pub conname: Option<String>, // char*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// InferenceElem - an element of a unique index inference specification
// This mostly matches the structure of IndexElems, but having a dedicated
// primnode allows for a clean separation between the use of index parameters
// by utility commands, and this node.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct InferenceElem {
    // expression to infer from, or NULL
    pub expr: Option<Box<Node>>, // Node*
    // OID of collation, or InvalidOid
    pub infercollid: Option<Oid>, // Oid
    // OID of att opclass, or InvalidOid
    pub inferopclass: Option<Oid>, // Oid
}

// DO Statement
// DoStmt is the raw parser output, InlineCodeBlock is the execution-time API
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct InlineCodeBlock {
    // source text of anonymous code block
    pub source_text: Option<String>, // char*
    // OID of selected language
    #[serde(rename = "langOid")]
    pub lang_oid: Option<Oid>, // Oid
    // trusted property of the language
    #[serde(default, rename = "langIsTrusted")]
    pub lang_is_trusted: bool, // bool
}

// Insert Statement
// The source expression is represented by SelectStmt for both the
// SELECT and VALUES cases.  If selectStmt is NULL, then the query
// is INSERT ... DEFAULT VALUES.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct InsertStmt {
    // relation to insert into
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // optional: names of the target columns
    pub cols: Option<List>, // List*
    // the source SELECT/VALUES, or NULL
    #[serde(rename = "selectStmt")]
    pub select_stmt: Option<Box<Node>>, // Node*
    // ON CONFLICT clause
    #[serde(rename = "onConflictClause")]
    pub on_conflict_clause: Option<OnConflictClauseWrapper>, // OnConflictClause*
    // list of expressions to return
    #[serde(rename = "returningList")]
    pub returning_list: Option<List>, // List*
    // WITH clause
    #[serde(rename = "withClause")]
    pub with_clause: Option<WithClauseWrapper>, // WithClause*
    // OVERRIDING clause
    pub r#override: Option<OverridingKind>, // OverridingKind
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Integer {
    pub ival: i64, // long
}

// IntoClause - target information for SELECT INTO, CREATE TABLE AS, and
// CREATE MATERIALIZED VIEW
// For CREATE MATERIALIZED VIEW, viewQuery is the parsed-but-not-rewritten
// SELECT Query for the view; otherwise it's NULL.  (Although it's actually
// Query*, we declare it as Node* to avoid a forward reference.)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct IntoClause {
    // target relation name
    pub rel: Option<RangeVarWrapper>, // RangeVar*
    // column names to assign, or NIL
    #[serde(rename = "colNames")]
    pub col_names: Option<List>, // List*
    // options from WITH clause
    pub options: Option<List>, // List*
    // what do we do at COMMIT?
    #[serde(rename = "onCommit")]
    pub on_commit: Option<OnCommitAction>, // OnCommitAction
    // table space to use, or NULL
    #[serde(rename = "tableSpaceName")]
    pub table_space_name: Option<String>, // char*
    // materialized view's SELECT query
    #[serde(rename = "viewQuery")]
    pub view_query: Option<Box<Node>>, // Node*
    // true for WITH NO DATA
    #[serde(default, rename = "skipData")]
    pub skip_data: bool, // bool
}

// JoinExpr - for SQL JOIN expressions
// isNatural, usingClause, and quals are interdependent.  The user can write
// only one of NATURAL, USING(), or ON() (this is enforced by the grammar).
// If he writes NATURAL then parse analysis generates the equivalent USING()
// list, and from that fills in "quals" with the right equality comparisons.
// If he writes USING() then "quals" is filled with equality comparisons.
// If he writes ON() then only "quals" is set.  Note that NATURAL/USING
// are not equivalent to ON() since they also affect the output column list.
// alias is an Alias node representing the AS alias-clause attached to the
// join expression, or NULL if no clause.  NB: presence or absence of the
// alias has a critical impact on semantics, because a join with an alias
// restricts visibility of the tables/columns inside it.
// During parse analysis, an RTE is created for the Join, and its index
// is filled into rtindex.  This RTE is present mainly so that Vars can
// be created that refer to the outputs of the join.  The planner sometimes
// generates JoinExprs internally; these can have rtindex = 0 if there are
// no join alias variables referencing such joins.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct JoinExpr {
    // type of join
    pub jointype: JoinType, // JoinType
    // Natural join? Will need to shape table
    #[serde(default, rename = "isNatural")]
    pub is_natural: bool, // bool
    // left subtree
    pub larg: Box<Node>, // Node*
    // right subtree
    pub rarg: Box<Node>, // Node*
    // USING clause, if any (list of String)
    #[serde(rename = "usingClause")]
    pub using_clause: Option<Vec<StringStructWrapper>>, // List*
    // qualifiers on join, if any
    pub quals: Option<Box<Node>>, // Node*
    // user-written alias clause, if any
    pub alias: Option<AliasWrapper>, // Alias*
    // RT index assigned for join, or 0
    pub rtindex: Option<i64>, // int
}

// Listen Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ListenStmt {
    // condition name to listen on
    pub conditionname: Option<String>, // char*
}

// Load Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct LoadStmt {
    // file to load
    pub filename: Option<String>, // char*
}

// LOCK Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct LockStmt {
    // relations to lock
    pub relations: Option<List>, // List*
    // lock mode
    pub mode: Option<i64>, // int
    // no wait mode
    #[serde(default)]
    pub nowait: bool, // bool
}

// LockingClause - raw representation of FOR [NO KEY] UPDATE/[KEY] SHARE
// options
// Note: lockedRels == NIL means "all relations in query".  Otherwise it
// is a list of RangeVar nodes.  (We use RangeVar mainly because it carries
// a location field --- currently, parse analysis insists on unqualified
// names in LockingClause.)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct LockingClause {
    // FOR [KEY] UPDATE/SHARE relations
    #[serde(rename = "lockedRels")]
    pub locked_rels: Option<List>, // List*
    pub strength: Option<LockClauseStrength>, // LockClauseStrength
    // NOWAIT and SKIP LOCKED
    #[serde(rename = "waitPolicy")]
    pub wait_policy: Option<LockWaitPolicy>, // LockWaitPolicy
}

// MinMaxExpr - a GREATEST or LEAST function
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct MinMaxExpr {
    // common type of arguments and result
    pub minmaxtype: Option<Oid>, // Oid
    // OID of collation of result
    pub minmaxcollid: Option<Oid>, // Oid
    // OID of collation that function should use
    pub inputcollid: Option<Oid>, // Oid
    // function to execute
    pub op: Option<MinMaxOp>, // MinMaxOp
    // the arguments
    pub args: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// MultiAssignRef - element of a row source expression for UPDATE
// In an UPDATE target list, when we have SET (a,b,c) = row-valued-expression,
// we generate separate ResTarget items for each of a,b,c.  Their "val" trees
// are MultiAssignRef nodes numbered 1..n, linking to a common copy of the
// row-valued-expression (which parse analysis will process only once, when
// handling the MultiAssignRef with colno=1).
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct MultiAssignRef {
    // the row-valued expression
    pub source: Option<Box<Node>>, // Node*
    // column number for this target (1..n)
    pub colno: Option<i64>, // int
    // number of targets in the construct
    pub ncolumns: Option<i64>, // int
}

// NamedArgExpr - a named argument of a function
// This node type can only appear in the args list of a FuncCall or FuncExpr
// node.  We support pure positional call notation (no named arguments),
// named notation (all arguments are named), and mixed notation (unnamed
// arguments followed by named ones).
// Parse analysis sets argnumber to the positional index of the argument,
// but doesn't rearrange the argument list.
// The planner will convert argument lists to pure positional notation
// during expression preprocessing, so execution never sees a NamedArgExpr.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct NamedArgExpr {
    // the argument expression
    pub arg: Option<ExprWrapper>, // Expr*
    // the name
    pub name: Option<String>, // char*
    // argument's number in positional notation
    pub argnumber: Option<i64>, // int
    // argument name location, or -1 if unknown
    pub location: Option<i64>, // int
}

// NextValueExpr - get next value from sequence
// This has the same effect as calling the nextval() function, but it does not
// check permissions on the sequence.  This is used for identity columns,
// where the sequence is an implicit dependency without its own permissions.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct NextValueExpr {
    pub seqid: Option<Oid>, // Oid
    #[serde(rename = "typeId")]
    pub type_id: Option<Oid>, // Oid
}

// Notify Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct NotifyStmt {
    // condition name to notify
    pub conditionname: Option<String>, // char*
    // the payload string, or NULL if none
    pub payload: Option<String>, // char*
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Null {}

// NullTest
// NullTest represents the operation of testing a value for NULLness.
// The appropriate test is performed and returned as a boolean Datum.
// When argisrow is false, this simply represents a test for the null value.
// When argisrow is true, the input expression must yield a rowtype, and
// the node implements "row IS [NOT] NULL" per the SQL standard.  This
// includes checking individual fields for NULLness when the row datum
// itself isn't NULL.
// NOTE: the combination of a rowtype input and argisrow==false does NOT
// correspond to the SQL notation "row IS [NOT] NULL"; instead, this case
// represents the SQL notation "row IS [NOT] DISTINCT FROM NULL".
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct NullTest {
    // input expression
    pub arg: Option<ExprWrapper>, // Expr*
    // IS NULL, IS NOT NULL
    pub nulltesttype: Option<NullTestType>, // NullTestType
    // T to perform field-by-field null checks
    #[serde(default)]
    pub argisrow: bool, // bool
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Note: ObjectWithArgs carries only the types of the input parameters of the
// function.  So it is sufficient to identify an existing function, but it
// is not enough info to define a function nor to call it.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ObjectWithArgs {
    // qualified name of function/operator
    pub objname: Option<List>, // List*
    // list of Typename nodes
    pub objargs: Option<List>, // List*
    // argument list was omitted, so name must
    // be unique (note that objargs == NIL
    // means zero args)
    #[serde(default)]
    pub args_unspecified: bool, // bool
}

// OnConflictClause -
// representation of ON CONFLICT clause
// Note: OnConflictClause does not propagate into the Query representation.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct OnConflictClause {
    // DO NOTHING or UPDATE?
    pub action: Option<OnConflictAction>, // OnConflictAction
    // Optional index inference clause
    pub infer: Option<InferClauseWrapper>, // InferClause*
    // the target list (of ResTarget)
    #[serde(rename = "targetList")]
    pub target_list: Option<List>, // List*
    // qualifications
    #[serde(rename = "whereClause")]
    pub where_clause: Option<Box<Node>>, // Node*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// OnConflictExpr - represents an ON CONFLICT DO ... expression
// The optimizer requires a list of inference elements, and optionally a WHERE
// clause to infer a unique index.  The unique index (or, occasionally,
// indexes) inferred are used to arbitrate whether or not the alternative ON
// CONFLICT path is taken.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct OnConflictExpr {
    // DO NOTHING or UPDATE?
    pub action: Option<OnConflictAction>, // OnConflictAction
    // unique index arbiter list (of
    // InferenceElem's)
    #[serde(rename = "arbiterElems")]
    pub arbiter_elems: Option<List>, // List*
    // unique index arbiter WHERE clause
    #[serde(rename = "arbiterWhere")]
    pub arbiter_where: Option<Box<Node>>, // Node*
    // pg_constraint OID for arbiter
    pub constraint: Option<Oid>, // Oid
    // List of ON CONFLICT SET TargetEntrys
    #[serde(rename = "onConflictSet")]
    pub on_conflict_set: Option<List>, // List*
    // qualifiers to restrict UPDATE to
    #[serde(rename = "onConflictWhere")]
    pub on_conflict_where: Option<Box<Node>>, // Node*
    // RT index of 'excluded' relation
    #[serde(rename = "exclRelIndex")]
    pub excl_rel_index: Option<i64>, // int
    // tlist of the EXCLUDED pseudo relation
    #[serde(rename = "exclRelTlist")]
    pub excl_rel_tlist: Option<List>, // List*
}

// OpExpr - expression node for an operator invocation
// Semantically, this is essentially the same as a function call.
// Note that opfuncid is not necessarily filled in immediately on creation
// of the node.  The planner makes sure it is valid before passing the node
// tree to the executor, but during parsing/planning opfuncid can be 0.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct OpExpr {
    // PG_OPERATOR OID of the operator
    pub opno: Option<Oid>, // Oid
    // PG_PROC OID of underlying function
    pub opfuncid: Option<Oid>, // Oid
    // PG_TYPE OID of result value
    pub opresulttype: Option<Oid>, // Oid
    // true if operator returns set
    #[serde(default)]
    pub opretset: bool, // bool
    // OID of collation of result
    pub opcollid: Option<Oid>, // Oid
    // OID of collation that operator should use
    pub inputcollid: Option<Oid>, // Oid
    // arguments to the operator (1 or 2)
    pub args: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Param
// paramkind specifies the kind of parameter. The possible values
// for this field are:
// PARAM_EXTERN:  The parameter value is supplied from outside the plan.
// Such parameters are numbered from 1 to n.
// PARAM_EXEC:  The parameter is an internal executor parameter, used
// for passing values into and out of sub-queries or from
// nestloop joins to their inner scans.
// For historical reasons, such parameters are numbered from 0.
// These numbers are independent of PARAM_EXTERN numbers.
// PARAM_SUBLINK:	The parameter represents an output column of a SubLink
// node's sub-select.  The column number is contained in the
// `paramid' field.  (This type of Param is converted to
// PARAM_EXEC during planning.)
// PARAM_MULTIEXPR:  Like PARAM_SUBLINK, the parameter represents an
// output column of a SubLink node's sub-select, but here, the
// SubLink is always a MULTIEXPR SubLink.  The high-order 16 bits
// of the `paramid' field contain the SubLink's subLinkId, and
// the low-order 16 bits contain the column number.  (This type
// of Param is also converted to PARAM_EXEC during planning.)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Param {
    // kind of parameter. See above
    pub paramkind: ParamKind, // ParamKind
    // numeric ID for parameter
    pub paramid: Option<i64>, // int
    // pg_type OID of parameter's datatype
    pub paramtype: Option<Oid>, // Oid
    // typmod value, if known
    pub paramtypmod: Option<i32>, // int32
    // OID of collation, or InvalidOid if none
    pub paramcollid: Option<Oid>, // Oid
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// ParamRef - specifies a $n parameter reference
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ParamRef {
    // the number of the parameter
    pub number: Option<i64>, // int
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// PartitionBoundSpec - a partition bound specification
// This represents the portion of the partition key space assigned to a
// particular partition.  These are stored on disk in pg_class.relpartbound.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct PartitionBoundSpec {
    // see PARTITION_STRATEGY codes above
    pub strategy: Option<char>, // char
    // List of Consts (or A_Consts in raw tree)
    pub listdatums: Option<List>, // List*
    // List of PartitionRangeDatums
    pub lowerdatums: Option<List>, // List*
    // List of PartitionRangeDatums
    pub upperdatums: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// PartitionCmd - info for ALTER TABLE ATTACH/DETACH PARTITION commands
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct PartitionCmd {
    // name of partition to attach/detach
    pub name: Option<RangeVarWrapper>, // RangeVar*
    // FOR VALUES, if attaching
    pub bound: Option<PartitionBoundSpecWrapper>, // PartitionBoundSpec*
}

// PartitionElem - parse-time representation of a single partition key
// expr can be either a raw expression tree or a parse-analyzed expression.
// We don't store these on-disk, though.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct PartitionElem {
    // name of column to partition on, or NULL
    pub name: Option<String>, // char*
    // expression to partition on, or NULL
    pub expr: Option<Box<Node>>, // Node*
    // name of collation; NIL = default
    pub collation: Option<List>, // List*
    // name of desired opclass; NIL = default
    pub opclass: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct PartitionRangeDatum {
    pub kind: PartitionRangeDatumKind, // PartitionRangeDatumKind
    // Const (or A_Const in raw tree), if kind is
    // PARTITION_RANGE_DATUM_VALUE, else NULL
    pub value: Option<Box<Node>>, // Node*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// PartitionSpec - parse-time representation of a partition key specification
// This represents the key space we will be partitioning on.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct PartitionSpec {
    // partitioning strategy ('list' or 'range')
    pub strategy: Option<String>, // char*
    // List of PartitionElems
    #[serde(rename = "partParams")]
    pub part_params: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// PREPARE Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct PrepareStmt {
    // Name of plan, arbitrary
    pub name: Option<String>, // char*
    // Types of parameters (List of TypeName)
    pub argtypes: Option<Vec<TypeNameWrapper>>, // List*
    // The query itself (as a raw parsetree)
    pub query: Option<Box<Node>>, // Node*
}

// Query -
// Parse analysis turns all statements into a Query tree
// for further processing by the rewriter and planner.
// Utility statements (i.e. non-optimizable statements) have the
// utilityStmt field set, and the rest of the Query is mostly dummy.
// Planning converts a Query tree into a Plan tree headed by a PlannedStmt
// node --- the Query structure is not used by the executor.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Query {
    // select|insert|update|delete|utility
    #[serde(rename = "commandType")]
    pub command_type: Option<CmdType>, // CmdType
    // where did I come from?
    #[serde(rename = "querySource")]
    pub query_source: Option<QuerySource>, // QuerySource
    // query identifier (can be set by plugins)
    #[serde(rename = "queryId")]
    pub query_id: Option<u32>, // uint32
    // do I set the command result tag?
    #[serde(default, rename = "canSetTag")]
    pub can_set_tag: bool, // bool
    // non-null if commandType == CMD_UTILITY
    #[serde(rename = "utilityStmt")]
    pub utility_stmt: Option<Box<Node>>, // Node*
    // rtable index of target relation for
    // INSERT/UPDATE/DELETE; 0 for SELECT
    #[serde(rename = "resultRelation")]
    pub result_relation: Option<i64>, // int
    // has aggregates in tlist or havingQual
    #[serde(default, rename = "hasAggs")]
    pub has_aggs: bool, // bool
    // has window functions in tlist
    #[serde(default, rename = "hasWindowFuncs")]
    pub has_window_funcs: bool, // bool
    // has set-returning functions in tlist
    #[serde(default, rename = "hasTargetSRFs")]
    pub has_target_sr_fs: bool, // bool
    // has subquery SubLink
    #[serde(default, rename = "hasSubLinks")]
    pub has_sub_links: bool, // bool
    // distinctClause is from DISTINCT ON
    #[serde(default, rename = "hasDistinctOn")]
    pub has_distinct_on: bool, // bool
    // WITH RECURSIVE was specified
    #[serde(default, rename = "hasRecursive")]
    pub has_recursive: bool, // bool
    // has INSERT/UPDATE/DELETE in WITH
    #[serde(default, rename = "hasModifyingCTE")]
    pub has_modifying_cte: bool, // bool
    // FOR [KEY] UPDATE/SHARE was specified
    #[serde(default, rename = "hasForUpdate")]
    pub has_for_update: bool, // bool
    // rewriter has applied some RLS policy
    #[serde(default, rename = "hasRowSecurity")]
    pub has_row_security: bool, // bool
    // WITH list (of CommonTableExpr's)
    #[serde(rename = "cteList")]
    pub cte_list: Option<List>, // List*
    // list of range table entries
    pub rtable: Option<List>, // List*
    // table join tree (FROM and WHERE clauses)
    pub jointree: Option<FromExprWrapper>, // FromExpr*
    // target list (of TargetEntry)
    #[serde(rename = "targetList")]
    pub target_list: Option<List>, // List*
    // OVERRIDING clause
    pub r#override: Option<OverridingKind>, // OverridingKind
    // ON CONFLICT DO [NOTHING | UPDATE]
    #[serde(rename = "onConflict")]
    pub on_conflict: Option<OnConflictExprWrapper>, // OnConflictExpr*
    // return-values list (of TargetEntry)
    #[serde(rename = "returningList")]
    pub returning_list: Option<List>, // List*
    // a list of SortGroupClause's
    #[serde(rename = "groupClause")]
    pub group_clause: Option<Vec<SortGroupClauseWrapper>>, // List*
    // a list of GroupingSet's if present
    #[serde(rename = "groupingSets")]
    pub grouping_sets: Option<Vec<GroupingSetWrapper>>, // List*
    // qualifications applied to groups
    #[serde(rename = "havingQual")]
    pub having_qual: Option<Box<Node>>, // Node*
    // a list of WindowClause's
    #[serde(rename = "windowClause")]
    pub window_clause: Option<Vec<WindowClauseWrapper>>, // List*
    // a list of SortGroupClause's
    #[serde(rename = "distinctClause")]
    pub distinct_clause: Option<Vec<SortGroupClauseWrapper>>, // List*
    // a list of SortGroupClause's
    #[serde(rename = "sortClause")]
    pub sort_clause: Option<Vec<SortGroupClauseWrapper>>, // List*
    // # of result tuples to skip (int8 expr)
    #[serde(rename = "limitOffset")]
    pub limit_offset: Option<Box<Node>>, // Node*
    // # of result tuples to return (int8 expr)
    #[serde(rename = "limitCount")]
    pub limit_count: Option<Box<Node>>, // Node*
    // a list of RowMarkClause's
    #[serde(rename = "rowMarks")]
    pub row_marks: Option<Vec<RowMarkClauseWrapper>>, // List*
    // set-operation tree if this is top level of
    // a UNION/INTERSECT/EXCEPT query
    #[serde(rename = "setOperations")]
    pub set_operations: Option<Box<Node>>, // Node*
    // a list of pg_constraint OIDs that the query
    // depends on to be semantically valid
    #[serde(rename = "constraintDeps")]
    pub constraint_deps: Option<List>, // List*
    // a list of WithCheckOption's, which are
    // only added during rewrite and therefore
    // are not written out as part of Query.
    #[serde(rename = "withCheckOptions")]
    pub with_check_options: Option<Vec<WithCheckOptionWrapper>>, // List*
    // start location, or -1 if unknown
    pub stmt_location: Option<i64>, // int
    // length in bytes; 0 means "rest of string"
    pub stmt_len: Option<i64>, // int
}

// RangeFunction - function call appearing in a FROM clause
// functions is a List because we use this to represent the construct
// ROWS FROM(func1(...), func2(...), ...).  Each element of this list is a
// two-element sublist, the first element being the untransformed function
// call tree, and the second element being a possibly-empty list of ColumnDef
// nodes representing any columndef list attached to that function within the
// ROWS FROM() syntax.
// alias and coldeflist represent any alias and/or columndef list attached
// at the top level.  (We disallow coldeflist appearing both here and
// per-function, but that's checked in parse analysis, not by the grammar.)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeFunction {
    // does it have LATERAL prefix?
    #[serde(default)]
    pub lateral: bool, // bool
    // does it have WITH ORDINALITY suffix?
    #[serde(default)]
    pub ordinality: bool, // bool
    // is result of ROWS FROM() syntax?
    #[serde(default)]
    pub is_rowsfrom: bool, // bool
    // per-function information, see above
    pub functions: Option<List>, // List*
    // table alias & optional column aliases
    pub alias: Option<AliasWrapper>, // Alias*
    // list of ColumnDef nodes to describe result
    // of function returning RECORD
    pub coldeflist: Option<Vec<ColumnDefWrapper>>, // List*
}

// RangeSubselect - subquery appearing in a FROM clause
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeSubselect {
    // does it have LATERAL prefix?
    #[serde(default)]
    pub lateral: bool, // bool
    // the untransformed sub-select clause
    pub subquery: Box<SelectStmtWrapper>, // Node*
    // table alias & optional column aliases
    pub alias: Option<AliasWrapper>, // Alias*
}

// RangeTableFunc - raw form of "table functions" such as XMLTABLE
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeTableFunc {
    // does it have LATERAL prefix?
    #[serde(default)]
    pub lateral: bool, // bool
    // document expression
    pub docexpr: Option<Box<Node>>, // Node*
    // row generator expression
    pub rowexpr: Option<Box<Node>>, // Node*
    // list of namespaces as ResTarget
    pub namespaces: Option<List>, // List*
    // list of RangeTableFuncCol
    pub columns: Option<Vec<RangeTableFuncColWrapper>>, // List*
    // table alias & optional column aliases
    pub alias: Option<AliasWrapper>, // Alias*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// RangeTableFuncCol - one column in a RangeTableFunc->columns
// If for_ordinality is true (FOR ORDINALITY), then the column is an int4
// column and the rest of the fields are ignored.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeTableFuncCol {
    // name of generated column
    pub colname: Option<String>, // char*
    // type of generated column
    #[serde(rename = "typeName")]
    pub type_name: Option<TypeNameWrapper>, // TypeName*
    // does it have FOR ORDINALITY?
    #[serde(default)]
    pub for_ordinality: bool, // bool
    // does it have NOT NULL?
    #[serde(default)]
    pub is_not_null: bool, // bool
    // column filter expression
    pub colexpr: Option<Box<Node>>, // Node*
    // column default value expression
    pub coldefexpr: Option<Box<Node>>, // Node*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// RangeTableSample - TABLESAMPLE appearing in a raw FROM clause
// This node, appearing only in raw parse trees, represents
// <relation> TABLESAMPLE <method> (<params>) REPEATABLE (<num>)
// Currently, the <relation> can only be a RangeVar, but we might in future
// allow RangeSubselect and other options.  Note that the RangeTableSample
// is wrapped around the node representing the <relation>, rather than being
// a subfield of it.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeTableSample {
    // relation to be sampled
    pub relation: Option<Box<Node>>, // Node*
    // sampling method name (possibly qualified)
    pub method: Option<List>, // List*
    // argument(s) for sampling method
    pub args: Option<List>, // List*
    // REPEATABLE expression, or NULL if none
    pub repeatable: Option<Box<Node>>, // Node*
    // method name location, or -1 if unknown
    pub location: Option<i64>, // int
}

// RangeTblEntry -
// A range table is a List of RangeTblEntry nodes.
// A range table entry may represent a plain relation, a sub-select in
// FROM, or the result of a JOIN clause.  (Only explicit JOIN syntax
// produces an RTE, not the implicit join resulting from multiple FROM
// items.  This is because we only need the RTE to deal with SQL features
// like outer joins and join-output-column aliasing.)  Other special
// RTE types also exist, as indicated by RTEKind.
// Note that we consider RTE_RELATION to cover anything that has a pg_class
// entry.  relkind distinguishes the sub-cases.
// alias is an Alias node representing the AS alias-clause attached to the
// FROM expression, or NULL if no clause.
// eref is the table reference name and column reference names (either
// real or aliases).  Note that system columns (OID etc) are not included
// in the column list.
// eref->aliasname is required to be present, and should generally be used
// to identify the RTE for error messages etc.
// In RELATION RTEs, the colnames in both alias and eref are indexed by
// physical attribute number; this means there must be colname entries for
// dropped columns.  When building an RTE we insert empty strings ("") for
// dropped columns.  Note however that a stored rule may have nonempty
// colnames for columns dropped since the rule was created (and for that
// matter the colnames might be out of date due to column renamings).
// The same comments apply to FUNCTION RTEs when a function's return type
// is a named composite type.
// In JOIN RTEs, the colnames in both alias and eref are one-to-one with
// joinaliasvars entries.  A JOIN RTE will omit columns of its inputs when
// those columns are known to be dropped at parse time.  Again, however,
// a stored rule might contain entries for columns dropped since the rule
// was created.  (This is only possible for columns not actually referenced
// in the rule.)  When loading a stored rule, we replace the joinaliasvars
// items for any such columns with null pointers.  (We can't simply delete
// them from the joinaliasvars list, because that would affect the attnums
// of Vars referencing the rest of the list.)
// inh is TRUE for relation references that should be expanded to include
// inheritance children, if the rel has any.  This *must* be FALSE for
// RTEs other than RTE_RELATION entries.
// inFromCl marks those range variables that are listed in the FROM clause.
// It's false for RTEs that are added to a query behind the scenes, such
// as the NEW and OLD variables for a rule, or the subqueries of a UNION.
// This flag is not used anymore during parsing, since the parser now uses
// a separate "namespace" data structure to control visibility, but it is
// needed by ruleutils.c to determine whether RTEs should be shown in
// decompiled queries.
// requiredPerms and checkAsUser specify run-time access permissions
// checks to be performed at query startup.  The user must have *all*
// of the permissions that are OR'd together in requiredPerms (zero
// indicates no permissions checking).  If checkAsUser is not zero,
// then do the permissions checks using the access rights of that user,
// not the current effective user ID.  (This allows rules to act as
// setuid gateways.)  Permissions checks only apply to RELATION RTEs.
// For SELECT/INSERT/UPDATE permissions, if the user doesn't have
// table-wide permissions then it is sufficient to have the permissions
// on all columns identified in selectedCols (for SELECT) and/or
// insertedCols and/or updatedCols (INSERT with ON CONFLICT DO UPDATE may
// have all 3).  selectedCols, insertedCols and updatedCols are bitmapsets,
// which cannot have negative integer members, so we subtract
// FirstLowInvalidHeapAttributeNumber from column numbers before storing
// them in these fields.  A whole-row Var reference is represented by
// setting the bit for InvalidAttrNumber.
// securityQuals is a list of security barrier quals (boolean expressions),
// to be tested in the listed order before returning a row from the
// relation.  It is always NIL in parser output.  Entries are added by the
// rewriter to implement security-barrier views and/or row-level security.
// Note that the planner turns each boolean expression into an implicitly
// AND'ed sublist, as is its usual habit with qualification expressions.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeTblEntry {
    // see above
    pub rtekind: RTEKind, // RTEKind
    // OID of the relation
    pub relid: Option<Oid>, // Oid
    // relation kind (see pg_class.relkind)
    pub relkind: char, // char
    // sampling info, or NULL
    pub tablesample: Option<TableSampleClauseWrapper>, // TableSampleClause*
    // the sub-query
    pub subquery: Option<QueryWrapper>, // Query*
    // is from security_barrier view?
    #[serde(default)]
    pub security_barrier: bool, // bool
    // type of join
    pub jointype: Option<JoinType>, // JoinType
    // list of alias-var expansions
    pub joinaliasvars: Option<List>, // List*
    // list of RangeTblFunction nodes
    pub functions: Option<Vec<RangeTblFunctionWrapper>>, // List*
    // is this called WITH ORDINALITY?
    #[serde(default)]
    pub funcordinality: bool, // bool
    pub tablefunc: Option<TableFuncWrapper>, // TableFunc*
    // list of expression lists
    pub values_lists: Option<List>, // List*
    // name of the WITH list item
    pub ctename: Option<String>, // char*
    // number of query levels up
    pub ctelevelsup: Option<Index>, // Index
    // is this a recursive self-reference?
    #[serde(default)]
    pub self_reference: bool, // bool
    // OID list of column type OIDs
    pub coltypes: Option<List>, // List*
    // integer list of column typmods
    pub coltypmods: Option<List>, // List*
    // OID list of column collation OIDs
    pub colcollations: Option<List>, // List*
    // name of ephemeral named relation
    pub enrname: Option<String>, // char*
    // estimated or actual from caller
    pub enrtuples: Option<f64>, // double
    // user-written alias clause, if any
    pub alias: Option<AliasWrapper>, // Alias*
    // expanded reference names
    pub eref: Option<AliasWrapper>, // Alias*
    // subquery, function, or values is LATERAL?
    #[serde(default)]
    pub lateral: bool, // bool
    // inheritance requested?
    #[serde(default)]
    pub inh: bool, // bool
    // present in FROM clause?
    #[serde(default, rename = "inFromCl")]
    pub in_from_cl: bool, // bool
    // bitmask of required access permissions
    #[serde(rename = "requiredPerms")]
    pub required_perms: Option<AclMode>, // AclMode
    // if valid, check access as this role
    #[serde(rename = "checkAsUser")]
    pub check_as_user: Option<Oid>, // Oid
    // columns needing SELECT permission
    #[serde(rename = "selectedCols")]
    pub selected_cols: Option<Vec<u32>>, // Bitmapset*
    // columns needing INSERT permission
    #[serde(rename = "insertedCols")]
    pub inserted_cols: Option<Vec<u32>>, // Bitmapset*
    // columns needing UPDATE permission
    #[serde(rename = "updatedCols")]
    pub updated_cols: Option<Vec<u32>>, // Bitmapset*
    // security barrier quals to apply, if any
    #[serde(rename = "securityQuals")]
    pub security_quals: Option<List>, // List*
}

// RangeTblFunction -
// RangeTblEntry subsidiary data for one function in a FUNCTION RTE.
// If the function had a column definition list (required for an
// otherwise-unspecified RECORD result), funccolnames lists the names given
// in the definition list, funccoltypes lists their declared column types,
// funccoltypmods lists their typmods, funccolcollations their collations.
// Otherwise, those fields are NIL.
// Notice we don't attempt to store info about the results of functions
// returning named composite types, because those can change from time to
// time.  We do however remember how many columns we thought the type had
// (including dropped columns!), so that we can successfully ignore any
// columns added after the query was parsed.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeTblFunction {
    // expression tree for func call
    pub funcexpr: Option<Box<Node>>, // Node*
    // number of columns it contributes to RTE
    pub funccolcount: Option<i64>, // int
    // column names (list of String)
    pub funccolnames: Option<Vec<StringStructWrapper>>, // List*
    // OID list of column type OIDs
    pub funccoltypes: Option<List>, // List*
    // integer list of column typmods
    pub funccoltypmods: Option<List>, // List*
    // OID list of column collation OIDs
    pub funccolcollations: Option<List>, // List*
    // PARAM_EXEC Param IDs affecting this func
    pub funcparams: Option<Vec<u32>>, // Bitmapset*
}

// RangeTblRef - reference to an entry in the query's rangetable
// We could use direct pointers to the RT entries and skip having these
// nodes, but multiple pointers to the same node in a querytree cause
// lots of headaches, so it seems better to store an index into the RT.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeTblRef {
    pub rtindex: Option<i64>, // int
}

// RangeVar - range variable, used in FROM clauses
// Also used to represent table names in utility statements; there, the alias
// field is not used, and inh tells whether to apply the operation
// recursively to child tables.  In some contexts it is also useful to carry
// a TEMP table indication here.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RangeVar {
    // the catalog (database) name, or NULL
    pub catalogname: Option<String>, // char*
    // the schema name, or NULL
    pub schemaname: Option<String>, // char*
    // the relation/sequence name
    pub relname: String, // char*
    // expand rel by inheritance? recursively act
    // on children?
    #[serde(default)]
    pub inh: bool, // bool
    // see RELPERSISTENCE_* in pg_class.h
    pub relpersistence: Option<char>, // char
    // table alias & optional column aliases
    pub alias: Option<AliasWrapper>, // Alias*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// RawStmt --- container for any one statement's raw parse tree
// Parse analysis converts a raw parse tree headed by a RawStmt node into
// an analyzed statement headed by a Query node.  For optimizable statements,
// the conversion is complex.  For utility statements, the parser usually just
// transfers the raw parse tree (sans RawStmt) into the utilityStmt field of
// the Query node, and all the useful work happens at execution time.
// stmt_location/stmt_len identify the portion of the source text string
// containing this raw statement (useful for multi-statement strings).
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RawStmt {
    // raw parse tree
    pub stmt: Node, // Node*
    // start location, or -1 if unknown
    pub stmt_location: Option<i64>, // int
    // length in bytes; 0 means "rest of string"
    pub stmt_len: Option<i64>, // int
}

// REASSIGN OWNED statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ReassignOwnedStmt {
    pub roles: Option<List>,              // List*
    pub newrole: Option<RoleSpecWrapper>, // RoleSpec*
}

// REFRESH MATERIALIZED VIEW Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RefreshMatViewStmt {
    // allow concurrent access?
    #[serde(default)]
    pub concurrent: bool, // bool
    // true for WITH NO DATA
    #[serde(default, rename = "skipData")]
    pub skip_data: bool, // bool
    // relation to insert into
    pub relation: Option<RangeVarWrapper>, // RangeVar*
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ReindexStmt {
    // REINDEX_OBJECT_INDEX, REINDEX_OBJECT_TABLE,
    // etc.
    pub kind: ReindexObjectType, // ReindexObjectType
    // Table or index to reindex
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // name of database to reindex
    pub name: Option<String>, // char*
    // Reindex options flags
    pub options: Option<i64>, // int
}

// RelabelType
// RelabelType represents a "dummy" type coercion between two binary-
// compatible datatypes, such as reinterpreting the result of an OID
// expression as an int4.  It is a no-op at runtime; we only need it
// to provide a place to store the correct type to be attributed to
// the expression result during type resolution.  (We can't get away
// with just overwriting the type field of the input expression node,
// so we need a separate node to show the coercion's result type.)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RelabelType {
    // input expression
    pub arg: Option<ExprWrapper>, // Expr*
    // output type of coercion expression
    pub resulttype: Option<Oid>, // Oid
    // output typmod (usually -1)
    pub resulttypmod: Option<i32>, // int32
    // OID of collation, or InvalidOid if none
    pub resultcollid: Option<Oid>, // Oid
    // how to display this node
    pub relabelformat: Option<CoercionForm>, // CoercionForm
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Alter Object Rename Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RenameStmt {
    // OBJECT_TABLE, OBJECT_COLUMN, etc
    #[serde(rename = "renameType")]
    pub rename_type: Option<ObjectType>, // ObjectType
    // if column name, associated relation type
    #[serde(rename = "relationType")]
    pub relation_type: Option<ObjectType>, // ObjectType
    // in case it's a table
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // in case it's some other object
    pub object: Option<Box<Node>>, // Node*
    // name of contained object (column, rule,
    // trigger, etc)
    pub subname: Option<String>, // char*
    // the new name
    pub newname: Option<String>, // char*
    // RESTRICT or CASCADE behavior
    pub behavior: Option<DropBehavior>, // DropBehavior
    // skip error if missing?
    #[serde(default)]
    pub missing_ok: bool, // bool
}

// Alter Table
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ReplicaIdentityStmt {
    pub identity_type: Option<char>, // char
    pub name: Option<String>,        // char*
}

// ResTarget -
// result target (used in target list of pre-transformed parse trees)
// In a SELECT target list, 'name' is the column label from an
// 'AS ColumnLabel' clause, or NULL if there was none, and 'val' is the
// value expression itself.  The 'indirection' field is not used.
// INSERT uses ResTarget in its target-column-names list.  Here, 'name' is
// the name of the destination column, 'indirection' stores any subscripts
// attached to the destination, and 'val' is not used.
// In an UPDATE target list, 'name' is the name of the destination column,
// 'indirection' stores any subscripts attached to the destination, and
// 'val' is the expression to assign.
// See A_Indirection for more info about what can appear in 'indirection'.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ResTarget {
    // column name or NULL
    pub name: Option<String>, // char*
    // subscripts, field names, and '*', or NIL
    pub indirection: Option<List>, // List*
    // the value expression to compute or assign
    pub val: Box<Node>, // Node*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RoleSpec {
    // Type of this rolespec
    pub roletype: Option<RoleSpecType>, // RoleSpecType
    // filled only for ROLESPEC_CSTRING
    pub rolename: Option<String>, // char*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// RowCompareExpr - row-wise comparison, such as (a, b) <= (1, 2)
// We support row comparison for any operator that can be determined to
// act like =, <>, <, <=, >, or >= (we determine this by looking for the
// operator in btree opfamilies).  Note that the same operator name might
// map to a different operator for each pair of row elements, since the
// element datatypes can vary.
// A RowCompareExpr node is only generated for the < <= > >= cases;
// the = and <> cases are translated to simple AND or OR combinations
// of the pairwise comparisons.  However, we include = and <> in the
// RowCompareType enum for the convenience of parser logic.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RowCompareExpr {
    // LT LE GE or GT, never EQ or NE
    pub rctype: Option<RowCompareType>, // RowCompareType
    // OID list of pairwise comparison ops
    pub opnos: Option<List>, // List*
    // OID list of containing operator families
    pub opfamilies: Option<List>, // List*
    // OID list of collations for comparisons
    pub inputcollids: Option<List>, // List*
    // the left-hand input arguments
    pub largs: Option<List>, // List*
    // the right-hand input arguments
    pub rargs: Option<List>, // List*
}

// RowExpr - a ROW() expression
// Note: the list of fields must have a one-for-one correspondence with
// physical fields of the associated rowtype, although it is okay for it
// to be shorter than the rowtype.  That is, the N'th list element must
// match up with the N'th physical field.  When the N'th physical field
// is a dropped column (attisdropped) then the N'th list element can just
// be a NULL constant.  (This case can only occur for named composite types,
// not RECORD types, since those are built from the RowExpr itself rather
// than vice versa.)  It is important not to assume that length(args) is
// the same as the number of columns logically present in the rowtype.
// colnames provides field names in cases where the names can't easily be
// obtained otherwise.  Names *must* be provided if row_typeid is RECORDOID.
// If row_typeid identifies a known composite type, colnames can be NIL to
// indicate the type's cataloged field names apply.  Note that colnames can
// be non-NIL even for a composite type, and typically is when the RowExpr
// was created by expanding a whole-row Var.  This is so that we can retain
// the column alias names of the RTE that the Var referenced (which would
// otherwise be very difficult to extract from the parsetree).  Like the
// args list, colnames is one-for-one with physical fields of the rowtype.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RowExpr {
    // the fields
    pub args: List, // List*
    // RECORDOID or a composite type's ID
    pub row_typeid: Option<Oid>, // Oid
    // how to display this node
    pub row_format: CoercionForm, // CoercionForm
    // list of String, or NIL
    pub colnames: Option<Vec<StringStructWrapper>>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// RowMarkClause -
// parser output representation of FOR [KEY] UPDATE/SHARE clauses
// Query.rowMarks contains a separate RowMarkClause node for each relation
// identified as a FOR [KEY] UPDATE/SHARE target.  If one of these clauses
// is applied to a subquery, we generate RowMarkClauses for all normal and
// subquery rels in the subquery, but they are marked pushedDown = true to
// distinguish them from clauses that were explicitly written at this query
// level.  Also, Query.hasForUpdate tells whether there were explicit FOR
// UPDATE/SHARE/KEY SHARE clauses in the current query level.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RowMarkClause {
    // range table index of target relation
    pub rti: Option<Index>,                   // Index
    pub strength: Option<LockClauseStrength>, // LockClauseStrength
    // NOWAIT and SKIP LOCKED
    #[serde(rename = "waitPolicy")]
    pub wait_policy: Option<LockWaitPolicy>, // LockWaitPolicy
    // pushed down from higher query level?
    #[serde(default, rename = "pushedDown")]
    pub pushed_down: bool, // bool
}

// Create Rule Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct RuleStmt {
    // relation the rule is for
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // name of the rule
    pub rulename: Option<String>, // char*
    // qualifications
    #[serde(rename = "whereClause")]
    pub where_clause: Option<Box<Node>>, // Node*
    // SELECT, INSERT, etc
    pub event: Option<CmdType>, // CmdType
    // is a 'do instead'?
    #[serde(default)]
    pub instead: bool, // bool
    // the action statements
    pub actions: Option<List>, // List*
    // OR REPLACE
    #[serde(default)]
    pub replace: bool, // bool
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SQLValueFunction {
    // which function this is
    pub op: Option<SQLValueFunctionOp>, // SQLValueFunctionOp
    pub typmod: Option<i32>,            // int32
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// ScalarArrayOpExpr - expression node for "scalar op ANY/ALL (array)"
// The operator must yield boolean.  It is applied to the left operand
// and each element of the righthand array, and the results are combined
// with OR or AND (for ANY or ALL respectively).  The node representation
// is almost the same as for the underlying operator, but we need a useOr
// flag to remember whether it's ANY or ALL, and we don't have to store
// the result type (or the collation) because it must be boolean.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ScalarArrayOpExpr {
    // PG_OPERATOR OID of the operator
    pub opno: Option<Oid>, // Oid
    // PG_PROC OID of underlying function
    pub opfuncid: Option<Oid>, // Oid
    // true for ANY, false for ALL
    #[serde(default, rename = "useOr")]
    pub use_or: bool, // bool
    // OID of collation that operator should use
    pub inputcollid: Option<Oid>, // Oid
    // the scalar and array operands
    pub args: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// SECURITY LABEL Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SecLabelStmt {
    // Object's type
    pub objtype: Option<ObjectType>, // ObjectType
    // Qualified name of the object
    pub object: Option<Box<Node>>, // Node*
    // Label provider (or NULL)
    pub provider: Option<String>, // char*
    // New security label to be assigned
    pub label: Option<String>, // char*
}

// Select Statement
// A "simple" SELECT is represented in the output of gram.y by a single
// SelectStmt node; so is a VALUES construct.  A query containing set
// operators (UNION, INTERSECT, EXCEPT) is represented by a tree of SelectStmt
// nodes, in which the leaf nodes are component SELECTs and the internal nodes
// represent UNION, INTERSECT, or EXCEPT operators.  Using the same node
// type for both leaf and internal nodes allows gram.y to stick ORDER BY,
// LIMIT, etc, clause values into a SELECT statement without worrying
// whether it is a simple or compound SELECT.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SelectStmt {
    // NULL, list of DISTINCT ON exprs, or
    // lcons(NIL,NIL) for all (SELECT DISTINCT)
    #[serde(rename = "distinctClause")]
    pub distinct_clause: Option<List>, // List*
    // target for SELECT INTO
    #[serde(rename = "intoClause")]
    pub into_clause: Option<IntoClauseWrapper>, // IntoClause*
    // the target list (of ResTarget)
    #[serde(rename = "targetList")]
    pub target_list: Option<List>, // List*
    // the FROM clause
    #[serde(rename = "fromClause")]
    pub from_clause: Option<List>, // List*
    // WHERE qualification
    #[serde(rename = "whereClause")]
    pub where_clause: Option<Box<Node>>, // Node*
    // GROUP BY clauses
    #[serde(rename = "groupClause")]
    pub group_clause: Option<List>, // List*
    // HAVING conditional-expression
    #[serde(rename = "havingClause")]
    pub having_clause: Option<Box<Node>>, // Node*
    // WINDOW window_name AS (...), ...
    #[serde(rename = "windowClause")]
    pub window_clause: Option<List>, // List*
    // untransformed list of expression lists
    #[serde(rename = "valuesLists")]
    pub values_lists: Option<Vec<List>>, // List*
    // sort clause (a list of SortBy's)
    #[serde(rename = "sortClause")]
    pub sort_clause: Option<Vec<SortByWrapper>>, // List*
    // # of result tuples to skip
    #[serde(rename = "limitOffset")]
    pub limit_offset: Option<Box<Node>>, // Node*
    // # of result tuples to return
    #[serde(rename = "limitCount")]
    pub limit_count: Option<Box<Node>>, // Node*
    // FOR UPDATE (list of LockingClause's)
    #[serde(rename = "lockingClause")]
    pub locking_clause: Option<Vec<LockingClauseWrapper>>, // List*
    // WITH clause
    #[serde(rename = "withClause")]
    pub with_clause: Option<WithClauseWrapper>, // WithClause*
    // type of set op
    pub op: Option<SetOperation>, // SetOperation
    // ALL specified?
    #[serde(default)]
    pub all: bool, // bool
    // left child
    pub larg: Option<Box<SelectStmtWrapper>>, // SelectStmt*
    // right child
    pub rarg: Option<Box<SelectStmtWrapper>>, // SelectStmt*
}

// Set Operation node for post-analysis query trees
// After parse analysis, a SELECT with set operations is represented by a
// top-level Query node containing the leaf SELECTs as subqueries in its
// range table.  Its setOperations field shows the tree of set operations,
// with leaf SelectStmt nodes replaced by RangeTblRef nodes, and internal
// nodes replaced by SetOperationStmt nodes.  Information about the output
// column types is added, too.  (Note that the child nodes do not necessarily
// produce these types directly, but we've checked that their output types
// can be coerced to the output column type.)  Also, if it's not UNION ALL,
// information about the types' sort/group semantics is provided in the form
// of a SortGroupClause list (same representation as, eg, DISTINCT).
// The resolved common column collations are provided too; but note that if
// it's not UNION ALL, it's okay for a column to not have a common collation,
// so a member of the colCollations list could be InvalidOid even though the
// column has a collatable type.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SetOperationStmt {
    // type of set op
    pub op: Option<SetOperation>, // SetOperation
    // ALL specified?
    #[serde(default)]
    pub all: bool, // bool
    // left child
    pub larg: Option<Box<Node>>, // Node*
    // right child
    pub rarg: Option<Box<Node>>, // Node*
    // OID list of output column type OIDs
    #[serde(rename = "colTypes")]
    pub col_types: Option<List>, // List*
    // integer list of output column typmods
    #[serde(rename = "colTypmods")]
    pub col_typmods: Option<List>, // List*
    // OID list of output column collation OIDs
    #[serde(rename = "colCollations")]
    pub col_collations: Option<List>, // List*
    // a list of SortGroupClause's
    #[serde(rename = "groupClauses")]
    pub group_clauses: Option<Vec<SortGroupClauseWrapper>>, // List*
}

// Placeholder node for a DEFAULT marker in an INSERT or UPDATE command.
// This is not an executable expression: it must be replaced by the actual
// column default expression during rewriting.  But it is convenient to
// treat it as an expression node during parsing and rewriting.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SetToDefault {
    // type for substituted value
    #[serde(rename = "typeId")]
    pub type_id: Option<Oid>, // Oid
    // typemod for substituted value
    #[serde(rename = "typeMod")]
    pub type_mod: Option<i32>, // int32
    // collation for the substituted value
    pub collation: Option<Oid>, // Oid
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// SortBy - for ORDER BY clause
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SortBy {
    // expression to sort on
    pub node: Box<Node>, // Node*
    // ASC/DESC/USING/default
    pub sortby_dir: SortByDir, // SortByDir
    // NULLS FIRST/LAST
    pub sortby_nulls: SortByNulls, // SortByNulls
    // name of op to use, if SORTBY_USING
    #[serde(rename = "useOp")]
    pub use_op: Option<List>, // List*
    // operator location, or -1 if none/unknown
    pub location: Option<i64>, // int
}

// SortGroupClause -
// representation of ORDER BY, GROUP BY, PARTITION BY,
// DISTINCT, DISTINCT ON items
// You might think that ORDER BY is only interested in defining ordering,
// and GROUP/DISTINCT are only interested in defining equality.  However,
// one way to implement grouping is to sort and then apply a "uniq"-like
// filter.  So it's also interesting to keep track of possible sort operators
// for GROUP/DISTINCT, and in particular to try to sort for the grouping
// in a way that will also yield a requested ORDER BY ordering.  So we need
// to be able to compare ORDER BY and GROUP/DISTINCT lists, which motivates
// the decision to give them the same representation.
// tleSortGroupRef must match ressortgroupref of exactly one entry of the
// query's targetlist; that is the expression to be sorted or grouped by.
// eqop is the OID of the equality operator.
// sortop is the OID of the ordering operator (a "<" or ">" operator),
// or InvalidOid if not available.
// nulls_first means about what you'd expect.  If sortop is InvalidOid
// then nulls_first is meaningless and should be set to false.
// hashable is TRUE if eqop is hashable (note this condition also depends
// on the datatype of the input expression).
// In an ORDER BY item, all fields must be valid.  (The eqop isn't essential
// here, but it's cheap to get it along with the sortop, and requiring it
// to be valid eases comparisons to grouping items.)  Note that this isn't
// actually enough information to determine an ordering: if the sortop is
// collation-sensitive, a collation OID is needed too.  We don't store the
// collation in SortGroupClause because it's not available at the time the
// parser builds the SortGroupClause; instead, consult the exposed collation
// of the referenced targetlist expression to find out what it is.
// In a grouping item, eqop must be valid.  If the eqop is a btree equality
// operator, then sortop should be set to a compatible ordering operator.
// We prefer to set eqop/sortop/nulls_first to match any ORDER BY item that
// the query presents for the same tlist item.  If there is none, we just
// use the default ordering op for the datatype.
// If the tlist item's type has a hash opclass but no btree opclass, then
// we will set eqop to the hash equality operator, sortop to InvalidOid,
// and nulls_first to false.  A grouping item of this kind can only be
// implemented by hashing, and of course it'll never match an ORDER BY item.
// The hashable flag is provided since we generally have the requisite
// information readily available when the SortGroupClause is constructed,
// and it's relatively expensive to get it again later.  Note there is no
// need for a "sortable" flag since OidIsValid(sortop) serves the purpose.
// A query might have both ORDER BY and DISTINCT (or DISTINCT ON) clauses.
// In SELECT DISTINCT, the distinctClause list is as long or longer than the
// sortClause list, while in SELECT DISTINCT ON it's typically shorter.
// The two lists must match up to the end of the shorter one --- the parser
// rearranges the distinctClause if necessary to make this true.  (This
// restriction ensures that only one sort step is needed to both satisfy the
// ORDER BY and set up for the Unique step.  This is semantically necessary
// for DISTINCT ON, and presents no real drawback for DISTINCT.)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SortGroupClause {
    // reference into targetlist
    #[serde(rename = "tleSortGroupRef")]
    pub tle_sort_group_ref: Option<Index>, // Index
    // the equality operator ('=' op)
    pub eqop: Option<Oid>, // Oid
    // the ordering operator ('<' op), or 0
    pub sortop: Option<Oid>, // Oid
    // do NULLs come before normal values?
    #[serde(default)]
    pub nulls_first: bool, // bool
    // can eqop be implemented by hashing?
    #[serde(default)]
    pub hashable: bool, // bool
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename = "String")]
pub struct StringStruct {
    pub str: String, // char*
}

// SubLink
// A SubLink represents a subselect appearing in an expression, and in some
// cases also the combining operator(s) just above it.  The subLinkType
// indicates the form of the expression represented:
// EXISTS_SUBLINK		EXISTS(SELECT ...)
// ALL_SUBLINK			(lefthand) op ALL (SELECT ...)
// ANY_SUBLINK			(lefthand) op ANY (SELECT ...)
// ROWCOMPARE_SUBLINK	(lefthand) op (SELECT ...)
// EXPR_SUBLINK		(SELECT with single targetlist item ...)
// MULTIEXPR_SUBLINK	(SELECT with multiple targetlist items ...)
// ARRAY_SUBLINK		ARRAY(SELECT with single targetlist item ...)
// CTE_SUBLINK			WITH query (never actually part of an expression)
// For ALL, ANY, and ROWCOMPARE, the lefthand is a list of expressions of the
// same length as the subselect's targetlist.  ROWCOMPARE will *always* have
// a list with more than one entry; if the subselect has just one target
// then the parser will create an EXPR_SUBLINK instead (and any operator
// above the subselect will be represented separately).
// ROWCOMPARE, EXPR, and MULTIEXPR require the subselect to deliver at most
// one row (if it returns no rows, the result is NULL).
// ALL, ANY, and ROWCOMPARE require the combining operators to deliver boolean
// results.  ALL and ANY combine the per-row results using AND and OR
// semantics respectively.
// ARRAY requires just one target column, and creates an array of the target
// column's type using any number of rows resulting from the subselect.
// SubLink is classed as an Expr node, but it is not actually executable;
// it must be replaced in the expression tree by a SubPlan node during
// planning.
// NOTE: in the raw output of gram.y, testexpr contains just the raw form
// of the lefthand expression (if any), and operName is the String name of
// the combining operator.  Also, subselect is a raw parsetree.  During parse
// analysis, the parser transforms testexpr into a complete boolean expression
// that compares the lefthand value(s) to PARAM_SUBLINK nodes representing the
// output columns of the subselect.  And subselect is transformed to a Query.
// This is the representation seen in saved rules and in the rewriter.
// In EXISTS, EXPR, MULTIEXPR, and ARRAY SubLinks, testexpr and operName
// are unused and are always null.
// subLinkId is currently used only for MULTIEXPR SubLinks, and is zero in
// other SubLinks.  This number identifies different multiple-assignment
// subqueries within an UPDATE statement's SET list.  It is unique only
// within a particular targetlist.  The output column(s) of the MULTIEXPR
// are referenced by PARAM_MULTIEXPR Params appearing elsewhere in the tlist.
// The CTE_SUBLINK case never occurs in actual SubLink nodes, but it is used
// in SubPlans generated for WITH subqueries.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SubLink {
    // see above
    #[serde(rename = "subLinkType")]
    pub sub_link_type: SubLinkType, // SubLinkType
    // ID (1..n); 0 if not MULTIEXPR
    #[serde(rename = "subLinkId")]
    pub sub_link_id: Option<i64>, // int
    // outer-query test for ALL/ANY/ROWCOMPARE
    pub testexpr: Option<Box<Node>>, // Node*
    // originally specified operator name
    #[serde(rename = "operName")]
    pub oper_name: Option<List>, // List*
    // subselect as Query* or raw parsetree
    pub subselect: Box<Node>, // Node*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// SubPlan - executable expression node for a subplan (sub-SELECT)
// The planner replaces SubLink nodes in expression trees with SubPlan
// nodes after it has finished planning the subquery.  SubPlan references
// a sub-plantree stored in the subplans list of the toplevel PlannedStmt.
// (We avoid a direct link to make it easier to copy expression trees
// without causing multiple processing of the subplan.)
// In an ordinary subplan, testexpr points to an executable expression
// (OpExpr, an AND/OR tree of OpExprs, or RowCompareExpr) for the combining
// operator(s); the left-hand arguments are the original lefthand expressions,
// and the right-hand arguments are PARAM_EXEC Param nodes representing the
// outputs of the sub-select.  (NOTE: runtime coercion functions may be
// inserted as well.)  This is just the same expression tree as testexpr in
// the original SubLink node, but the PARAM_SUBLINK nodes are replaced by
// suitably numbered PARAM_EXEC nodes.
// If the sub-select becomes an initplan rather than a subplan, the executable
// expression is part of the outer plan's expression tree (and the SubPlan
// node itself is not, but rather is found in the outer plan's initPlan
// list).  In this case testexpr is NULL to avoid duplication.
// The planner also derives lists of the values that need to be passed into
// and out of the subplan.  Input values are represented as a list "args" of
// expressions to be evaluated in the outer-query context (currently these
// args are always just Vars, but in principle they could be any expression).
// The values are assigned to the global PARAM_EXEC params indexed by parParam
// (the parParam and args lists must have the same ordering).  setParam is a
// list of the PARAM_EXEC params that are computed by the sub-select, if it
// is an initplan; they are listed in order by sub-select output column
// position.  (parParam and setParam are integer Lists, not Bitmapsets,
// because their ordering is significant.)
// Also, the planner computes startup and per-call costs for use of the
// SubPlan.  Note that these include the cost of the subquery proper,
// evaluation of the testexpr if any, and any hashtable management overhead.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct SubPlan {
    // see above
    #[serde(rename = "subLinkType")]
    pub sub_link_type: Option<SubLinkType>, // SubLinkType
    // OpExpr or RowCompareExpr expression tree
    pub testexpr: Option<Box<Node>>, // Node*
    // IDs of Params embedded in the above
    #[serde(rename = "paramIds")]
    pub param_ids: Option<List>, // List*
    // Index (from 1) in PlannedStmt.subplans
    pub plan_id: Option<i64>, // int
    // A name assigned during planning
    pub plan_name: Option<String>, // char*
    // Type of first column of subplan result
    #[serde(rename = "firstColType")]
    pub first_col_type: Option<Oid>, // Oid
    // Typmod of first column of subplan result
    #[serde(rename = "firstColTypmod")]
    pub first_col_typmod: Option<i32>, // int32
    // Collation of first column of subplan
    // result
    #[serde(rename = "firstColCollation")]
    pub first_col_collation: Option<Oid>, // Oid
    // TRUE to store subselect output in a hash
    // table (implies we are doing "IN")
    #[serde(default, rename = "useHashTable")]
    pub use_hash_table: bool, // bool
    // TRUE if it's okay to return FALSE when the
    // spec result is UNKNOWN; this allows much
    // simpler handling of null values
    #[serde(default, rename = "unknownEqFalse")]
    pub unknown_eq_false: bool, // bool
    // is the subplan parallel-safe?
    #[serde(default)]
    pub parallel_safe: bool, // bool
    // initplan subqueries have to set these
    // Params for parent plan
    #[serde(rename = "setParam")]
    pub set_param: Option<List>, // List*
    // indices of input Params from parent plan
    #[serde(rename = "parParam")]
    pub par_param: Option<List>, // List*
    // exprs to pass as parParam values
    pub args: Option<List>, // List*
    // one-time setup cost
    pub startup_cost: Option<f64>, // Cost
    // cost for each subplan evaluation
    pub per_call_cost: Option<f64>, // Cost
}

// TableFunc - node for a table function, such as XMLTABLE.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TableFunc {
    // list of namespace uri
    pub ns_uris: Option<List>, // List*
    // list of namespace names
    pub ns_names: Option<List>, // List*
    // input document expression
    pub docexpr: Option<Box<Node>>, // Node*
    // row filter expression
    pub rowexpr: Option<Box<Node>>, // Node*
    // column names (list of String)
    pub colnames: Option<Vec<StringStructWrapper>>, // List*
    // OID list of column type OIDs
    pub coltypes: Option<List>, // List*
    // integer list of column typmods
    pub coltypmods: Option<List>, // List*
    // OID list of column collation OIDs
    pub colcollations: Option<List>, // List*
    // list of column filter expressions
    pub colexprs: Option<List>, // List*
    // list of column default expressions
    pub coldefexprs: Option<List>, // List*
    // nullability flag for each output column
    pub notnulls: Option<Vec<u32>>, // Bitmapset*
    // counts from 0; -1 if none specified
    pub ordinalitycol: Option<i64>, // int
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// TableLikeClause - CREATE TABLE ( ... LIKE ... ) clause
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TableLikeClause {
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // OR of TableLikeOption flags
    pub options: Option<u32>, // bits32
}

// TableSampleClause - TABLESAMPLE appearing in a transformed FROM clause
// Unlike RangeTableSample, this is a subnode of the relevant RangeTblEntry.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TableSampleClause {
    // OID of the tablesample handler function
    pub tsmhandler: Option<Oid>, // Oid
    // tablesample argument expression(s)
    pub args: Option<List>, // List*
    // REPEATABLE expression, or NULL if none
    pub repeatable: Option<ExprWrapper>, // Expr*
}

// TargetEntry -
// a target entry (used in query target lists)
// Strictly speaking, a TargetEntry isn't an expression node (since it can't
// be evaluated by ExecEvalExpr).  But we treat it as one anyway, since in
// very many places it's convenient to process a whole query targetlist as a
// single expression tree.
// In a SELECT's targetlist, resno should always be equal to the item's
// ordinal position (counting from 1).  However, in an INSERT or UPDATE
// targetlist, resno represents the attribute number of the destination
// column for the item; so there may be missing or out-of-order resnos.
// It is even legal to have duplicated resnos; consider
// UPDATE table SET arraycol[1] = ..., arraycol[2] = ..., ...
// The two meanings come together in the executor, because the planner
// transforms INSERT/UPDATE tlists into a normalized form with exactly
// one entry for each column of the destination table.  Before that's
// happened, however, it is risky to assume that resno == position.
// Generally get_tle_by_resno() should be used rather than list_nth()
// to fetch tlist entries by resno, and only in SELECT should you assume
// that resno is a unique identifier.
// resname is required to represent the correct column name in non-resjunk
// entries of top-level SELECT targetlists, since it will be used as the
// column title sent to the frontend.  In most other contexts it is only
// a debugging aid, and may be wrong or even NULL.  (In particular, it may
// be wrong in a tlist from a stored rule, if the referenced column has been
// renamed by ALTER TABLE since the rule was made.  Also, the planner tends
// to store NULL rather than look up a valid name for tlist entries in
// non-toplevel plan nodes.)  In resjunk entries, resname should be either
// a specific system-generated name (such as "ctid") or NULL; anything else
// risks confusing ExecGetJunkAttribute!
// ressortgroupref is used in the representation of ORDER BY, GROUP BY, and
// DISTINCT items.  Targetlist entries with ressortgroupref=0 are not
// sort/group items.  If ressortgroupref>0, then this item is an ORDER BY,
// GROUP BY, and/or DISTINCT target value.  No two entries in a targetlist
// may have the same nonzero ressortgroupref --- but there is no particular
// meaning to the nonzero values, except as tags.  (For example, one must
// not assume that lower ressortgroupref means a more significant sort key.)
// The order of the associated SortGroupClause lists determine the semantics.
// resorigtbl/resorigcol identify the source of the column, if it is a
// simple reference to a column of a base table (or view).  If it is not
// a simple reference, these fields are zeroes.
// If resjunk is true then the column is a working column (such as a sort key)
// that should be removed from the final output of the query.  Resjunk columns
// must have resnos that cannot duplicate any regular column's resno.  Also
// note that there are places that assume resjunk columns come after non-junk
// columns.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TargetEntry {
    // expression to evaluate
    pub expr: Option<ExprWrapper>, // Expr*
    // attribute number (see notes above)
    pub resno: Option<AttrNumber>, // AttrNumber
    // name of the column (could be NULL)
    pub resname: Option<String>, // char*
    // nonzero if referenced by a sort/group
    // clause
    pub ressortgroupref: Option<Index>, // Index
    // OID of column's source table
    pub resorigtbl: Option<Oid>, // Oid
    // column's number in source table
    pub resorigcol: Option<AttrNumber>, // AttrNumber
    // set to true to eliminate the attribute from
    // final target list
    #[serde(default)]
    pub resjunk: bool, // bool
}

// {Begin|Commit|Rollback} Transaction Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TransactionStmt {
    // see above
    pub kind: TransactionStmtKind, // TransactionStmtKind
    // for BEGIN/START and savepoint commands
    pub options: Option<List>, // List*
    // for two-phase-commit related commands
    pub gid: Option<String>, // char*
}

// TriggerTransition -
// representation of transition row or table naming clause
// Only transition tables are initially supported in the syntax, and only for
// AFTER triggers, but other permutations are accepted by the parser so we can
// give a meaningful message from C code.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TriggerTransition {
    pub name: Option<String>, // char*
    #[serde(default, rename = "isNew")]
    pub is_new: bool, // bool
    #[serde(default, rename = "isTable")]
    pub is_table: bool, // bool
}

// Truncate Table Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TruncateStmt {
    // relations (RangeVars) to be truncated
    pub relations: Option<List>, // List*
    // restart owned sequences?
    #[serde(default)]
    pub restart_seqs: bool, // bool
    // RESTRICT or CASCADE behavior
    pub behavior: Option<DropBehavior>, // DropBehavior
}

// TypeCast - a CAST expression
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TypeCast {
    // the expression being casted
    pub arg: Option<Box<Node>>, // Node*
    // the target type
    #[serde(rename = "typeName")]
    pub type_name: Option<TypeNameWrapper>, // TypeName*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// TypeName - specifies a type in definitions
// For TypeName structures generated internally, it is often easier to
// specify the type by OID than by name.  If "names" is NIL then the
// actual type OID is given by typeOid, otherwise typeOid is unused.
// Similarly, if "typmods" is NIL then the actual typmod is expected to
// be prespecified in typemod, otherwise typemod is unused.
// If pct_type is TRUE, then names is actually a field name and we look up
// the type of that field.  Otherwise (the normal case), names is a type
// name possibly qualified with schema and database name.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct TypeName {
    // qualified name (list of Value strings)
    pub names: Vec<StringStructWrapper>, // List*
    // type identified by OID
    #[serde(rename = "typeOid")]
    pub type_oid: Option<Oid>, // Oid
    // is a set?
    #[serde(default)]
    pub setof: bool, // bool
    // %TYPE specified?
    #[serde(default)]
    pub pct_type: bool, // bool
    // type modifier expression(s)
    pub typmods: Option<List>, // List*
    // prespecified type modifier
    pub typemod: Option<i32>, // int32
    // array bounds
    #[serde(rename = "arrayBounds")]
    pub array_bounds: Option<List>, // List*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// Unlisten Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct UnlistenStmt {
    // name to unlisten on, or NULL for all
    pub conditionname: Option<String>, // char*
}

// Update Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct UpdateStmt {
    // relation to update
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // the target list (of ResTarget)
    #[serde(rename = "targetList")]
    pub target_list: Option<List>, // List*
    // qualifications
    #[serde(rename = "whereClause")]
    pub where_clause: Option<Box<Node>>, // Node*
    // optional from clause for more tables
    #[serde(rename = "fromClause")]
    pub from_clause: Option<List>, // List*
    // list of expressions to return
    #[serde(rename = "returningList")]
    pub returning_list: Option<List>, // List*
    // WITH clause
    #[serde(rename = "withClause")]
    pub with_clause: Option<WithClauseWrapper>, // WithClause*
}

// Vacuum and Analyze Statements
// Even though these are nominally two statements, it's convenient to use
// just one node type for both.  Note that at least one of VACOPT_VACUUM
// and VACOPT_ANALYZE must be set in options.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct VacuumStmt {
    // OR of VacuumOption flags
    pub options: Option<i64>, // int
    // single table to process, or NULL
    pub relation: Option<RangeVarWrapper>, // RangeVar*
    // list of column names, or NIL for all
    pub va_cols: Option<List>, // List*
}

// Symbols for the indexes of the special RTE entries in rules
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct Var {
    // index of this var's relation in the range
    // table, or INNER_VAR/OUTER_VAR/INDEX_VAR
    pub varno: Option<Index>, // Index
    // attribute number of this var, or zero for
    // all
    pub varattno: Option<AttrNumber>, // AttrNumber
    // pg_type OID for the type of this var
    pub vartype: Option<Oid>, // Oid
    // pg_attribute typmod value
    pub vartypmod: Option<i32>, // int32
    // OID of collation, or InvalidOid if none
    pub varcollid: Option<Oid>, // Oid
    // for subquery variables referencing outer
    // relations; 0 in a normal var, >0 means N
    // levels up
    pub varlevelsup: Option<Index>, // Index
    // original value of varno, for debugging
    pub varnoold: Option<Index>, // Index
    // original value of varattno
    pub varoattno: Option<AttrNumber>, // AttrNumber
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct VariableSetStmt {
    pub kind: VariableSetKind, // VariableSetKind
    // variable to be set
    pub name: Option<String>, // char*
    // List of A_Const nodes
    pub args: Option<List>, // List*
    // SET LOCAL?
    #[serde(default)]
    pub is_local: bool, // bool
}

// Show Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct VariableShowStmt {
    pub name: Option<String>, // char*
}

// Create View Statement
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct ViewStmt {
    // the view to be created
    pub view: Option<RangeVarWrapper>, // RangeVar*
    // target column names
    pub aliases: Option<List>, // List*
    // the SELECT query (as a raw parse tree)
    pub query: Option<Box<Node>>, // Node*
    // replace an existing view?
    #[serde(default)]
    pub replace: bool, // bool
    // options from WITH clause
    pub options: Option<List>, // List*
    // WITH CHECK OPTION
    #[serde(rename = "withCheckOption")]
    pub with_check_option: Option<ViewCheckOption>, // ViewCheckOption
}

// WindowClause -
// transformed representation of WINDOW and OVER clauses
// A parsed Query's windowClause list contains these structs.  "name" is set
// if the clause originally came from WINDOW, and is NULL if it originally
// was an OVER clause (but note that we collapse out duplicate OVERs).
// partitionClause and orderClause are lists of SortGroupClause structs.
// winref is an ID number referenced by WindowFunc nodes; it must be unique
// among the members of a Query's windowClause list.
// When refname isn't null, the partitionClause is always copied from there;
// the orderClause might or might not be copied (see copiedOrder); the framing
// options are never copied, per spec.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct WindowClause {
    // window name (NULL in an OVER clause)
    pub name: Option<String>, // char*
    // referenced window name, if any
    pub refname: Option<String>, // char*
    // PARTITION BY list
    #[serde(rename = "partitionClause")]
    pub partition_clause: Option<List>, // List*
    // ORDER BY list
    #[serde(rename = "orderClause")]
    pub order_clause: Option<List>, // List*
    // frame_clause options, see WindowDef
    #[serde(rename = "frameOptions")]
    pub frame_options: Option<i64>, // int
    // expression for starting bound, if any
    #[serde(rename = "startOffset")]
    pub start_offset: Option<Box<Node>>, // Node*
    // expression for ending bound, if any
    #[serde(rename = "endOffset")]
    pub end_offset: Option<Box<Node>>, // Node*
    // ID referenced by window functions
    pub winref: Option<Index>, // Index
    // did we copy orderClause from refname?
    #[serde(default, rename = "copiedOrder")]
    pub copied_order: bool, // bool
}

// WindowDef - raw representation of WINDOW and OVER clauses
// For entries in a WINDOW list, "name" is the window name being defined.
// For OVER clauses, we use "name" for the "OVER window" syntax, or "refname"
// for the "OVER (window)" syntax, which is subtly different --- the latter
// implies overriding the window frame clause.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct WindowDef {
    // window's own name
    pub name: Option<String>, // char*
    // referenced window name, if any
    pub refname: Option<String>, // char*
    // PARTITION BY expression list
    #[serde(rename = "partitionClause")]
    pub partition_clause: Option<List>, // List*
    // ORDER BY (list of SortBy)
    #[serde(rename = "orderClause")]
    pub order_clause: Option<Vec<SortByWrapper>>, // List*
    // frame_clause options, see below
    #[serde(rename = "frameOptions")]
    pub frame_options: Option<i64>, // int
    // expression for starting bound, if any
    #[serde(rename = "startOffset")]
    pub start_offset: Option<Box<Node>>, // Node*
    // expression for ending bound, if any
    #[serde(rename = "endOffset")]
    pub end_offset: Option<Box<Node>>, // Node*
    // parse location, or -1 if none/unknown
    pub location: Option<i64>, // int
}

// WindowFunc
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct WindowFunc {
    // pg_proc Oid of the function
    pub winfnoid: Option<Oid>, // Oid
    // type Oid of result of the window function
    pub wintype: Option<Oid>, // Oid
    // OID of collation of result
    pub wincollid: Option<Oid>, // Oid
    // OID of collation that function should use
    pub inputcollid: Option<Oid>, // Oid
    // arguments to the window function
    pub args: Option<List>, // List*
    // FILTER expression, if any
    pub aggfilter: Option<ExprWrapper>, // Expr*
    // index of associated WindowClause
    pub winref: Option<Index>, // Index
    // TRUE if argument list was really '*'
    #[serde(default)]
    pub winstar: bool, // bool
    // is function a simple aggregate?
    #[serde(default)]
    pub winagg: bool, // bool
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct WithCheckOption {
    // kind of WCO
    pub kind: WCOKind, // WCOKind
    // name of relation that specified the WCO
    pub relname: Option<String>, // char*
    // name of RLS policy being checked
    pub polname: Option<String>, // char*
    // constraint qual to check
    pub qual: Option<Box<Node>>, // Node*
    // true for a cascaded WCO on a view
    #[serde(default)]
    pub cascaded: bool, // bool
}

// WithClause -
// representation of WITH clause
// Note: WithClause does not propagate into the Query representation;
// but CommonTableExpr does.
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct WithClause {
    // list of CommonTableExprs
    pub ctes: Option<List>, // List*
    // true = WITH RECURSIVE
    #[serde(default)]
    pub recursive: bool, // bool
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct XmlExpr {
    // xml function ID
    pub op: Option<XmlExprOp>, // XmlExprOp
    // name in xml(NAME foo ...) syntaxes
    pub name: Option<String>, // char*
    // non-XML expressions for xml_attributes
    pub named_args: Option<List>, // List*
    // parallel list of Value strings
    pub arg_names: Option<Vec<StringStructWrapper>>, // List*
    // list of expressions
    pub args: Option<List>, // List*
    // DOCUMENT or CONTENT
    pub xmloption: Option<XmlOptionType>, // XmlOptionType
    pub typmod: Option<i32>,              // int32
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// XMLSERIALIZE (in raw parse tree only)
#[skip_serializing_none]
#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub struct XmlSerialize {
    // DOCUMENT or CONTENT
    pub xmloption: Option<XmlOptionType>, // XmlOptionType
    pub expr: Option<Box<Node>>,          // Node*
    #[serde(rename = "typeName")]
    pub type_name: Option<TypeNameWrapper>, // TypeName*
    // token location, or -1 if unknown
    pub location: Option<i64>, // int
}

// A_Expr - infix, prefix, and postfix expressions
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum AExprKind {
    // normal operator
    AExprOp,
    // scalar op ANY (array)
    AExprOpAny,
    // scalar op ALL (array)
    AExprOpAll,
    // IS DISTINCT FROM - name must be "="
    AExprDistinct,
    // IS NOT DISTINCT FROM - name must be "="
    AExprNotDistinct,
    // NULLIF - name must be "="
    AExprNullif,
    // IS [NOT] OF - name must be "=" or "<>"
    AExprOf,
    // [NOT] IN - name must be "=" or "<>"
    AExprIn,
    // [NOT] LIKE - name must be "~~" or "!~~"
    AExprLike,
    // [NOT] ILIKE - name must be "~~*" or "!~~*"
    AExprIlike,
    // [NOT] SIMILAR - name must be "~" or "!~"
    AExprSimilar,
    // name must be "BETWEEN"
    AExprBetween,
    // name must be "NOT BETWEEN"
    AExprNotBetween,
    // name must be "BETWEEN SYMMETRIC"
    AExprBetweenSym,
    // name must be "NOT BETWEEN SYMMETRIC"
    AExprNotBetweenSym,
    // nameless dummy node for parentheses
    AExprParen,
}

// Supported operating modes (i.e., useful combinations of these options):
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum AggSplit {
    AggsplitSimple,
    AggsplitInitialSerial,
    AggsplitFinalDeserial,
}

#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum AlterSubscriptionType {
    AlterSubscriptionOptions,
    AlterSubscriptionConnection,
    AlterSubscriptionPublication,
    AlterSubscriptionRefresh,
    AlterSubscriptionEnabled,
}

// TS Configuration stmts: DefineStmt, RenameStmt and DropStmt are default
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum AlterTSConfigType {
    AlterTsconfigAddMapping,
    AlterTsconfigAlterMappingForToken,
    AlterTsconfigReplaceDict,
    AlterTsconfigReplaceDictForToken,
    AlterTsconfigDropMapping,
}

#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum AlterTableType {
    // add column
    AtAddcolumn,
    // internal to commands/tablecmds.c
    AtAddcolumnrecurse,
    // implicitly via CREATE OR REPLACE VIEW
    AtAddcolumntoview,
    // alter column default
    AtColumndefault,
    // alter column drop not null
    AtDropnotnull,
    // alter column set not null
    AtSetnotnull,
    // alter column set statistics
    AtSetstatistics,
    // alter column set ( options )
    AtSetoptions,
    // alter column reset ( options )
    AtResetoptions,
    // alter column set storage
    AtSetstorage,
    // drop column
    AtDropcolumn,
    // internal to commands/tablecmds.c
    AtDropcolumnrecurse,
    // add index
    AtAddindex,
    // internal to commands/tablecmds.c
    AtReaddindex,
    // add constraint
    AtAddconstraint,
    // internal to commands/tablecmds.c
    AtAddconstraintrecurse,
    // internal to commands/tablecmds.c
    AtReaddconstraint,
    // alter constraint
    AtAlterconstraint,
    // validate constraint
    AtValidateconstraint,
    // internal to commands/tablecmds.c
    AtValidateconstraintrecurse,
    // pre-processed add constraint (local in
    // parser/parse_utilcmd.c)
    AtProcessedconstraint,
    // add constraint using existing index
    AtAddindexconstraint,
    // drop constraint
    AtDropconstraint,
    // internal to commands/tablecmds.c
    AtDropconstraintrecurse,
    // internal to commands/tablecmds.c
    AtReaddcomment,
    // alter column type
    AtAltercolumntype,
    // alter column OPTIONS (...)
    AtAltercolumngenericoptions,
    // change owner
    AtChangeowner,
    // CLUSTER ON
    AtClusteron,
    // SET WITHOUT CLUSTER
    AtDropcluster,
    // SET LOGGED
    AtSetlogged,
    // SET UNLOGGED
    AtSetunlogged,
    // SET WITH OIDS
    AtAddoids,
    // internal to commands/tablecmds.c
    AtAddoidsrecurse,
    // SET WITHOUT OIDS
    AtDropoids,
    // SET TABLESPACE
    AtSettablespace,
    // SET (...) -- AM specific parameters
    AtSetreloptions,
    // RESET (...) -- AM specific parameters
    AtResetreloptions,
    // replace reloption list in its entirety
    AtReplacereloptions,
    // ENABLE TRIGGER name
    AtEnabletrig,
    // ENABLE ALWAYS TRIGGER name
    AtEnablealwaystrig,
    // ENABLE REPLICA TRIGGER name
    AtEnablereplicatrig,
    // DISABLE TRIGGER name
    AtDisabletrig,
    // ENABLE TRIGGER ALL
    AtEnabletrigall,
    // DISABLE TRIGGER ALL
    AtDisabletrigall,
    // ENABLE TRIGGER USER
    AtEnabletriguser,
    // DISABLE TRIGGER USER
    AtDisabletriguser,
    // ENABLE RULE name
    AtEnablerule,
    // ENABLE ALWAYS RULE name
    AtEnablealwaysrule,
    // ENABLE REPLICA RULE name
    AtEnablereplicarule,
    // DISABLE RULE name
    AtDisablerule,
    // INHERIT parent
    AtAddinherit,
    // NO INHERIT parent
    AtDropinherit,
    // OF <type_name>
    AtAddof,
    // NOT OF
    AtDropof,
    // REPLICA IDENTITY
    AtReplicaidentity,
    // ENABLE ROW SECURITY
    AtEnablerowsecurity,
    // DISABLE ROW SECURITY
    AtDisablerowsecurity,
    // FORCE ROW SECURITY
    AtForcerowsecurity,
    // NO FORCE ROW SECURITY
    AtNoforcerowsecurity,
    // OPTIONS (...)
    AtGenericoptions,
    // ATTACH PARTITION
    AtAttachpartition,
    // DETACH PARTITION
    AtDetachpartition,
    // ADD IDENTITY
    AtAddidentity,
    // SET identity column options
    AtSetidentity,
    // DROP IDENTITY
    AtDropidentity,
}

// BoolExpr - expression node for the basic Boolean operators AND, OR, NOT
// Notice the arguments are given as a List.  For NOT, of course the list
// must always have exactly one element.  For AND and OR, there can be two
// or more arguments.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum BoolExprType {
    AndExpr,
    OrExpr,
    NotExpr,
}

// BooleanTest
// BooleanTest represents the operation of determining whether a boolean
// is TRUE, FALSE, or UNKNOWN (ie, NULL).  All six meaningful combinations
// are supported.  Note that a NULL input does *not* cause a NULL result.
// The appropriate test is performed and returned as a boolean Datum.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum BoolTestType {
    IsTrue,
    IsNotTrue,
}

// CmdType -
// enums for type of operation represented by a Query or PlannedStmt
// This is needed in both parsenodes.h and plannodes.h, so put it here...
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum CmdType {
    CmdUnknown,
    // select stmt
    CmdSelect,
    // update stmt
    CmdUpdate,
    // insert stmt
    CmdInsert,
    CmdDelete,
    // cmds like create, destroy, copy, vacuum,
    // etc.
    CmdUtility,
    // dummy command for instead nothing rules
    // with qual
    CmdNothing,
}

// CoercionContext - distinguishes the allowed set of type casts
// NB: ordering of the alternatives is significant; later (larger) values
// allow more casts than earlier ones.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum CoercionContext {
    // coercion in context of expression
    CoercionImplicit,
    // coercion in context of assignment
    CoercionAssignment,
    // explicit cast operation
    CoercionExplicit,
}

// CoercionForm - how to display a node that could have come from a cast
// NB: equal() ignores CoercionForm fields, therefore this *must* not carry
// any semantically significant information.  We need that behavior so that
// the planner will consider equivalent implicit and explicit casts to be
// equivalent.  In cases where those actually behave differently, the coercion
// function's arguments will be different.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum CoercionForm {
    // display as a function call
    CoerceExplicitCall,
    // display as an explicit cast
    CoerceExplicitCast,
    // implicit cast, so hide it
    CoerceImplicitCast,
}

// Definitions for constraints in CreateStmt
// Note that column defaults are treated as a type of constraint,
// even though that's a bit odd semantically.
// For constraints that use expressions (CONSTR_CHECK, CONSTR_DEFAULT)
// we may have the expression in either "raw" form (an untransformed
// parse tree) or "cooked" form (the nodeToString representation of
// an executable expression tree), depending on how this Constraint
// node was created (by parsing, or by inheritance from an existing
// relation).  We should never have both in the same node!
// FKCONSTR_ACTION_xxx values are stored into pg_constraint.confupdtype
// and pg_constraint.confdeltype columns; FKCONSTR_MATCH_xxx values are
// stored into pg_constraint.confmatchtype.  Changing the code values may
// require an initdb!
// If skip_validation is true then we skip checking that the existing rows
// in the table satisfy the constraint, and just install the catalog entries
// for the constraint.  A new FK constraint is marked as valid iff
// initially_valid is true.  (Usually skip_validation and initially_valid
// are inverses, but we can set both true if the table is known empty.)
// Constraint attributes (DEFERRABLE etc) are initially represented as
// separate Constraint nodes for simplicity of parsing.  parse_utilcmd.c makes
// a pass through the constraints list to insert the info into the appropriate
// Constraint node.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum ConstrType {
    // not standard SQL, but a lot of people
    // expect it
    ConstrNull,
    ConstrNotnull,
    ConstrDefault,
    ConstrIdentity,
    ConstrCheck,
    ConstrPrimary,
    ConstrUnique,
    ConstrExclusion,
    ConstrForeign,
    // attributes for previous constraint node
    ConstrAttrDeferrable,
    ConstrAttrNotDeferrable,
    ConstrAttrDeferred,
    ConstrAttrImmediate,
}

// DefElem - a generic "name = value" option definition
// In some contexts the name can be qualified.  Also, certain SQL commands
// allow a SET/ADD/DROP action to be attached to option settings, so it's
// convenient to carry a field for that too.  (Note: currently, it is our
// practice that the grammar allows namespace and action only in statements
// where they are relevant; C code can just ignore those fields in other
// statements.)
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum DefElemAction {
    // no action given
    DefelemUnspec,
    DefelemSet,
    DefelemAdd,
    DefelemDrop,
}

// Discard Statement
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum DiscardMode {
    DiscardAll,
    DiscardPlans,
    DiscardSequences,
    DiscardTemp,
}

#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum DropBehavior {
    // drop fails if any dependent objects
    DropRestrict,
    // remove dependent objects too
    DropCascade,
}

// Fetch Statement (also Move)
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum FetchDirection {
    FetchForward,
    FetchBackward,
    FetchAbsolute,
    FetchRelative,
}

#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum FunctionParameterMode {
    FuncParamIn = 105,
    FuncParamOut = 111,
    FuncParamInout = 98,
    FuncParamVariadic = 118,
    FuncParamTable = 116,
}

#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum GrantObjectType {
    // column
    AclObjectColumn,
    // table, view
    AclObjectRelation,
    // sequence
    AclObjectSequence,
    // database
    AclObjectDatabase,
    // domain
    AclObjectDomain,
    // foreign-data wrapper
    AclObjectFdw,
    // foreign server
    AclObjectForeignServer,
    // function
    AclObjectFunction,
    // procedural language
    AclObjectLanguage,
    // largeobject
    AclObjectLargeobject,
    // namespace
    AclObjectNamespace,
    // tablespace
    AclObjectTablespace,
    // type
    AclObjectType,
}

// Grant|Revoke Statement
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum GrantTargetType {
    // grant on specific named object(s)
    AclTargetObject,
    // grant on all objects in given schema(s)
    AclTargetAllInSchema,
    // ALTER DEFAULT PRIVILEGES
    AclTargetDefaults,
}

// GroupingSet -
// representation of CUBE, ROLLUP and GROUPING SETS clauses
// In a Query with grouping sets, the groupClause contains a flat list of
// SortGroupClause nodes for each distinct expression used.  The actual
// structure of the GROUP BY clause is given by the groupingSets tree.
// In the raw parser output, GroupingSet nodes (of all types except SIMPLE
// which is not used) are potentially mixed in with the expressions in the
// groupClause of the SelectStmt.  (An expression can't contain a GroupingSet,
// but a list may mix GroupingSet and expression nodes.)  At this stage, the
// content of each node is a list of expressions, some of which may be RowExprs
// which represent sublists rather than actual row constructors, and nested
// GroupingSet nodes where legal in the grammar.  The structure directly
// reflects the query syntax.
// In parse analysis, the transformed expressions are used to build the tlist
// and groupClause list (of SortGroupClause nodes), and the groupingSets tree
// is eventually reduced to a fixed format:
// EMPTY nodes represent (), and obviously have no content
// SIMPLE nodes represent a list of one or more expressions to be treated as an
// atom by the enclosing structure; the content is an integer list of
// ressortgroupref values (see SortGroupClause)
// CUBE and ROLLUP nodes contain a list of one or more SIMPLE nodes.
// SETS nodes contain a list of EMPTY, SIMPLE, CUBE or ROLLUP nodes, but after
// parse analysis they cannot contain more SETS nodes; enough of the syntactic
// transforms of the spec have been applied that we no longer have arbitrarily
// deep nesting (though we still preserve the use of cube/rollup).
// Note that if the groupingSets tree contains no SIMPLE nodes (only EMPTY
// nodes at the leaves), then the groupClause will be empty, but this is still
// an aggregation query (similar to using aggs or HAVING without GROUP BY).
// As an example, the following clause:
// GROUP BY GROUPING SETS ((a,b), CUBE(c,(d,e)))
// looks like this after raw parsing:
// SETS( RowExpr(a,b) , CUBE( c, RowExpr(d,e) ) )
// and parse analysis converts it to:
// SETS( SIMPLE(1,2), CUBE( SIMPLE(3), SIMPLE(4,5) ) )
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum GroupingSetKind {
    GroupingSetEmpty,
    GroupingSetSimple,
    GroupingSetRollup,
    GroupingSetCube,
    GroupingSetSets,
}

// Import Foreign Schema Statement
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum ImportForeignSchemaType {
    // all relations wanted
    FdwImportSchemaAll,
    // include only listed tables in import
    FdwImportSchemaLimitTo,
    // exclude listed tables from import
    FdwImportSchemaExcept,
}

// JoinType -
// enums for types of relation joins
// JoinType determines the exact semantics of joining two relations using
// a matching qualification.  For example, it tells what to do with a tuple
// that has no match in the other relation.
// This is needed in both parsenodes.h and plannodes.h, so put it here...
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum JoinType {
    // matching tuple pairs only
    JoinInner,
    // pairs + unmatched LHS tuples
    JoinLeft,
    // pairs + unmatched LHS + unmatched RHS
    JoinFull,
    // pairs + unmatched RHS tuples
    JoinRight,
    // 1 copy of each LHS row that has match(es)
    JoinSemi,
    // 1 copy of each LHS row that has no match
    JoinAnti,
    // LHS path must be made unique
    JoinUniqueOuter,
    // RHS path must be made unique
    JoinUniqueInner,
}

// This enum represents the different strengths of FOR UPDATE/SHARE clauses.
// The ordering here is important, because the highest numerical value takes
// precedence when a RTE is specified multiple ways.  See applyLockingClause.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum LockClauseStrength {
    // no such clause - only used in PlanRowMark
    LcsNone,
    // FOR KEY SHARE
    LcsForkeyshare,
    // FOR SHARE
    LcsForshare,
    // FOR NO KEY UPDATE
    LcsFornokeyupdate,
    // FOR UPDATE
    LcsForupdate,
}

// This enum controls how to deal with rows being locked by FOR UPDATE/SHARE
// clauses (i.e., it represents the NOWAIT and SKIP LOCKED options).
// The ordering here is important, because the highest numerical value takes
// precedence when a RTE is specified multiple ways.  See applyLockingClause.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum LockWaitPolicy {
    Lockwaitblock,
    Lockwaitskip,
    Lockwaiterror,
}

// MinMaxExpr - a GREATEST or LEAST function
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum MinMaxOp {
    IsGreatest,
    IsLeast,
}

// NullTest
// NullTest represents the operation of testing a value for NULLness.
// The appropriate test is performed and returned as a boolean Datum.
// When argisrow is false, this simply represents a test for the null value.
// When argisrow is true, the input expression must yield a rowtype, and
// the node implements "row IS [NOT] NULL" per the SQL standard.  This
// includes checking individual fields for NULLness when the row datum
// itself isn't NULL.
// NOTE: the combination of a rowtype input and argisrow==false does NOT
// correspond to the SQL notation "row IS [NOT] NULL"; instead, this case
// represents the SQL notation "row IS [NOT] DISTINCT FROM NULL".
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum NullTestType {
    IsNull,
    IsNotNull,
}

// When a command can act on several kinds of objects with only one
// parse structure required, use these constants to designate the
// object type.  Note that commands typically don't support all the types.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum ObjectType {
    ObjectAccessMethod,
    ObjectAggregate,
    ObjectAmop,
    ObjectAmproc,
    // type's attribute, when distinct from column
    ObjectAttribute,
    ObjectCast,
    ObjectColumn,
    ObjectCollation,
    ObjectConversion,
    ObjectDatabase,
    ObjectDefault,
    ObjectDefacl,
    ObjectDomain,
    ObjectDomconstraint,
    ObjectEventTrigger,
    ObjectExtension,
    ObjectFdw,
    ObjectForeignServer,
    ObjectForeignTable,
    ObjectFunction,
    ObjectIndex,
    ObjectLanguage,
    ObjectLargeobject,
    ObjectMatview,
    ObjectOpclass,
    ObjectOperator,
    ObjectOpfamily,
    ObjectPolicy,
    ObjectPublication,
    ObjectPublicationRel,
    ObjectRole,
    ObjectRule,
    ObjectSchema,
    ObjectSequence,
    ObjectSubscription,
    ObjectStatisticExt,
    ObjectTabconstraint,
    ObjectTable,
    ObjectTablespace,
    ObjectTransform,
    ObjectTrigger,
    ObjectTsconfiguration,
    ObjectTsdictionary,
    ObjectTsparser,
    ObjectTstemplate,
    ObjectType,
    ObjectUserMapping,
    ObjectView,
}

// What to do at commit time for temporary relations
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum OnCommitAction {
    // No ON COMMIT clause (do nothing)
    OncommitNoop,
    // ON COMMIT PRESERVE ROWS (do nothing)
    OncommitPreserveRows,
    // ON COMMIT DELETE ROWS
    OncommitDeleteRows,
    // ON COMMIT DROP
    OncommitDrop,
}

// OnConflictAction -
// "ON CONFLICT" clause type of query
// This is needed in both parsenodes.h and plannodes.h, so put it here...
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum OnConflictAction {
    // No "ON CONFLICT" clause
    OnconflictNone,
    // ON CONFLICT ... DO NOTHING
    OnconflictNothing,
    // ON CONFLICT ... DO UPDATE
    OnconflictUpdate,
}

// parsenodes.h
// definitions for parse tree nodes
// Many of the node types used in parsetrees include a "location" field.
// This is a byte (not character) offset in the original source text, to be
// used for positioning an error cursor when there is an error related to
// the node.  Access to the original source text is needed to make use of
// the location.  At the topmost (statement) level, we also provide a
// statement length, likewise measured in bytes, for convenience in
// identifying statement boundaries in multi-statement source strings.
// Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
// Portions Copyright (c) 1994, Regents of the University of California
// src/include/nodes/parsenodes.h
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum OverridingKind {
    OverridingNotSet,
    OverridingUserValue,
    OverridingSystemValue,
}

// Param
// paramkind specifies the kind of parameter. The possible values
// for this field are:
// PARAM_EXTERN:  The parameter value is supplied from outside the plan.
// Such parameters are numbered from 1 to n.
// PARAM_EXEC:  The parameter is an internal executor parameter, used
// for passing values into and out of sub-queries or from
// nestloop joins to their inner scans.
// For historical reasons, such parameters are numbered from 0.
// These numbers are independent of PARAM_EXTERN numbers.
// PARAM_SUBLINK:	The parameter represents an output column of a SubLink
// node's sub-select.  The column number is contained in the
// `paramid' field.  (This type of Param is converted to
// PARAM_EXEC during planning.)
// PARAM_MULTIEXPR:  Like PARAM_SUBLINK, the parameter represents an
// output column of a SubLink node's sub-select, but here, the
// SubLink is always a MULTIEXPR SubLink.  The high-order 16 bits
// of the `paramid' field contain the SubLink's subLinkId, and
// the low-order 16 bits contain the column number.  (This type
// of Param is also converted to PARAM_EXEC during planning.)
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum ParamKind {
    ParamExtern,
    ParamExec,
    ParamSublink,
    ParamMultiexpr,
}

// PartitionRangeDatum - one of the values in a range partition bound
// This can be MINVALUE, MAXVALUE or a specific bounded value.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(i8)]
pub enum PartitionRangeDatumKind {
    PartitionRangeDatumMinvalue = -1,
    PartitionRangeDatumValue = 0,
    PartitionRangeDatumMaxvalue = 1,
}

// Possible sources of a Query
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum QuerySource {
    // original parsetree (explicit query)
    QsrcOriginal,
    // added by parse analysis (now unused)
    QsrcParser,
    // added by unconditional INSTEAD rule
    QsrcInsteadRule,
    // added by conditional INSTEAD rule
    QsrcQualInsteadRule,
    // added by non-INSTEAD rule
    QsrcNonInsteadRule,
}

// RangeTblEntry -
// A range table is a List of RangeTblEntry nodes.
// A range table entry may represent a plain relation, a sub-select in
// FROM, or the result of a JOIN clause.  (Only explicit JOIN syntax
// produces an RTE, not the implicit join resulting from multiple FROM
// items.  This is because we only need the RTE to deal with SQL features
// like outer joins and join-output-column aliasing.)  Other special
// RTE types also exist, as indicated by RTEKind.
// Note that we consider RTE_RELATION to cover anything that has a pg_class
// entry.  relkind distinguishes the sub-cases.
// alias is an Alias node representing the AS alias-clause attached to the
// FROM expression, or NULL if no clause.
// eref is the table reference name and column reference names (either
// real or aliases).  Note that system columns (OID etc) are not included
// in the column list.
// eref->aliasname is required to be present, and should generally be used
// to identify the RTE for error messages etc.
// In RELATION RTEs, the colnames in both alias and eref are indexed by
// physical attribute number; this means there must be colname entries for
// dropped columns.  When building an RTE we insert empty strings ("") for
// dropped columns.  Note however that a stored rule may have nonempty
// colnames for columns dropped since the rule was created (and for that
// matter the colnames might be out of date due to column renamings).
// The same comments apply to FUNCTION RTEs when a function's return type
// is a named composite type.
// In JOIN RTEs, the colnames in both alias and eref are one-to-one with
// joinaliasvars entries.  A JOIN RTE will omit columns of its inputs when
// those columns are known to be dropped at parse time.  Again, however,
// a stored rule might contain entries for columns dropped since the rule
// was created.  (This is only possible for columns not actually referenced
// in the rule.)  When loading a stored rule, we replace the joinaliasvars
// items for any such columns with null pointers.  (We can't simply delete
// them from the joinaliasvars list, because that would affect the attnums
// of Vars referencing the rest of the list.)
// inh is TRUE for relation references that should be expanded to include
// inheritance children, if the rel has any.  This *must* be FALSE for
// RTEs other than RTE_RELATION entries.
// inFromCl marks those range variables that are listed in the FROM clause.
// It's false for RTEs that are added to a query behind the scenes, such
// as the NEW and OLD variables for a rule, or the subqueries of a UNION.
// This flag is not used anymore during parsing, since the parser now uses
// a separate "namespace" data structure to control visibility, but it is
// needed by ruleutils.c to determine whether RTEs should be shown in
// decompiled queries.
// requiredPerms and checkAsUser specify run-time access permissions
// checks to be performed at query startup.  The user must have *all*
// of the permissions that are OR'd together in requiredPerms (zero
// indicates no permissions checking).  If checkAsUser is not zero,
// then do the permissions checks using the access rights of that user,
// not the current effective user ID.  (This allows rules to act as
// setuid gateways.)  Permissions checks only apply to RELATION RTEs.
// For SELECT/INSERT/UPDATE permissions, if the user doesn't have
// table-wide permissions then it is sufficient to have the permissions
// on all columns identified in selectedCols (for SELECT) and/or
// insertedCols and/or updatedCols (INSERT with ON CONFLICT DO UPDATE may
// have all 3).  selectedCols, insertedCols and updatedCols are bitmapsets,
// which cannot have negative integer members, so we subtract
// FirstLowInvalidHeapAttributeNumber from column numbers before storing
// them in these fields.  A whole-row Var reference is represented by
// setting the bit for InvalidAttrNumber.
// securityQuals is a list of security barrier quals (boolean expressions),
// to be tested in the listed order before returning a row from the
// relation.  It is always NIL in parser output.  Entries are added by the
// rewriter to implement security-barrier views and/or row-level security.
// Note that the planner turns each boolean expression into an implicitly
// AND'ed sublist, as is its usual habit with qualification expressions.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum RTEKind {
    // ordinary relation reference
    RteRelation,
    // subquery in FROM
    RteSubquery,
    // join
    RteJoin,
    // function in FROM
    RteFunction,
    // TableFunc(.., column list)
    RteTablefunc,
    // VALUES (<exprlist>), (<exprlist>), ...
    RteValues,
    // common table expr (WITH list element)
    RteCte,
    // tuplestore, e.g. for AFTER triggers
    RteNamedtuplestore,
}

// Reindex options
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum ReindexObjectType {
    // index
    ReindexObjectIndex,
    // table or materialized view
    ReindexObjectTable,
    // schema
    ReindexObjectSchema,
    // system catalogs
    ReindexObjectSystem,
    // database
    ReindexObjectDatabase,
}

// RoleSpec - a role name or one of a few special values.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum RoleSpecType {
    // role name is stored as a C string
    RolespecCstring,
    // role spec is CURRENT_USER
    RolespecCurrentUser,
    // role spec is SESSION_USER
    RolespecSessionUser,
    // role name is "public"
    RolespecPublic,
}

// Create/Alter/Drop Role Statements
// Note: these node types are also used for the backwards-compatible
// Create/Alter/Drop User/Group statements.  In the ALTER and DROP cases
// there's really no need to distinguish what the original spelling was,
// but for CREATE we mark the type because the defaults vary.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum RoleStmtType {
    RolestmtRole,
    RolestmtUser,
    RolestmtGroup,
}

// RowCompareExpr - row-wise comparison, such as (a, b) <= (1, 2)
// We support row comparison for any operator that can be determined to
// act like =, <>, <, <=, >, or >= (we determine this by looking for the
// operator in btree opfamilies).  Note that the same operator name might
// map to a different operator for each pair of row elements, since the
// element datatypes can vary.
// A RowCompareExpr node is only generated for the < <= > >= cases;
// the = and <> cases are translated to simple AND or OR combinations
// of the pairwise comparisons.  However, we include = and <> in the
// RowCompareType enum for the convenience of parser logic.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum RowCompareType {
    RowcompareLt,
    RowcompareLe,
    RowcompareEq,
    RowcompareGe,
    RowcompareGt,
    RowcompareNe,
}

// SQLValueFunction - parameterless functions with special grammar productions
// The SQL standard categorizes some of these as <datetime value function>
// and others as <general value specification>.  We call 'em SQLValueFunctions
// for lack of a better term.  We store type and typmod of the result so that
// some code doesn't need to know each function individually, and because
// we would need to store typmod anyway for some of the datetime functions.
// Note that currently, all variants return non-collating datatypes, so we do
// not need a collation field; also, all these functions are stable.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum SQLValueFunctionOp {
    SvfopCurrentDate,
    SvfopCurrentTime,
    SvfopCurrentTimeN,
    SvfopCurrentTimestamp,
    SvfopCurrentTimestampN,
    SvfopLocaltime,
    SvfopLocaltimeN,
    SvfopLocaltimestamp,
    SvfopLocaltimestampN,
    SvfopCurrentRole,
    SvfopCurrentUser,
    SvfopUser,
    SvfopSessionUser,
    SvfopCurrentCatalog,
    SvfopCurrentSchema,
}

// Select Statement
// A "simple" SELECT is represented in the output of gram.y by a single
// SelectStmt node; so is a VALUES construct.  A query containing set
// operators (UNION, INTERSECT, EXCEPT) is represented by a tree of SelectStmt
// nodes, in which the leaf nodes are component SELECTs and the internal nodes
// represent UNION, INTERSECT, or EXCEPT operators.  Using the same node
// type for both leaf and internal nodes allows gram.y to stick ORDER BY,
// LIMIT, etc, clause values into a SELECT statement without worrying
// whether it is a simple or compound SELECT.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum SetOperation {
    SetopNone,
    SetopUnion,
    SetopIntersect,
    SetopExcept,
}

// Sort ordering options for ORDER BY and CREATE INDEX
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum SortByDir {
    SortbyDefault,
    SortbyAsc,
    SortbyDesc,
    // not allowed in CREATE INDEX ...
    SortbyUsing,
}

#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum SortByNulls {
    SortbyNullsDefault,
    SortbyNullsFirst,
    SortbyNullsLast,
}

// SubLink
// A SubLink represents a subselect appearing in an expression, and in some
// cases also the combining operator(s) just above it.  The subLinkType
// indicates the form of the expression represented:
// EXISTS_SUBLINK		EXISTS(SELECT ...)
// ALL_SUBLINK			(lefthand) op ALL (SELECT ...)
// ANY_SUBLINK			(lefthand) op ANY (SELECT ...)
// ROWCOMPARE_SUBLINK	(lefthand) op (SELECT ...)
// EXPR_SUBLINK		(SELECT with single targetlist item ...)
// MULTIEXPR_SUBLINK	(SELECT with multiple targetlist items ...)
// ARRAY_SUBLINK		ARRAY(SELECT with single targetlist item ...)
// CTE_SUBLINK			WITH query (never actually part of an expression)
// For ALL, ANY, and ROWCOMPARE, the lefthand is a list of expressions of the
// same length as the subselect's targetlist.  ROWCOMPARE will *always* have
// a list with more than one entry; if the subselect has just one target
// then the parser will create an EXPR_SUBLINK instead (and any operator
// above the subselect will be represented separately).
// ROWCOMPARE, EXPR, and MULTIEXPR require the subselect to deliver at most
// one row (if it returns no rows, the result is NULL).
// ALL, ANY, and ROWCOMPARE require the combining operators to deliver boolean
// results.  ALL and ANY combine the per-row results using AND and OR
// semantics respectively.
// ARRAY requires just one target column, and creates an array of the target
// column's type using any number of rows resulting from the subselect.
// SubLink is classed as an Expr node, but it is not actually executable;
// it must be replaced in the expression tree by a SubPlan node during
// planning.
// NOTE: in the raw output of gram.y, testexpr contains just the raw form
// of the lefthand expression (if any), and operName is the String name of
// the combining operator.  Also, subselect is a raw parsetree.  During parse
// analysis, the parser transforms testexpr into a complete boolean expression
// that compares the lefthand value(s) to PARAM_SUBLINK nodes representing the
// output columns of the subselect.  And subselect is transformed to a Query.
// This is the representation seen in saved rules and in the rewriter.
// In EXISTS, EXPR, MULTIEXPR, and ARRAY SubLinks, testexpr and operName
// are unused and are always null.
// subLinkId is currently used only for MULTIEXPR SubLinks, and is zero in
// other SubLinks.  This number identifies different multiple-assignment
// subqueries within an UPDATE statement's SET list.  It is unique only
// within a particular targetlist.  The output column(s) of the MULTIEXPR
// are referenced by PARAM_MULTIEXPR Params appearing elsewhere in the tlist.
// The CTE_SUBLINK case never occurs in actual SubLink nodes, but it is used
// in SubPlans generated for WITH subqueries.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum SubLinkType {
    ExistsSublink,
    AllSublink,
    AnySublink,
    RowcompareSublink,
    ExprSublink,
    MultiexprSublink,
    ArraySublink,
    // for SubPlans only
    CteSublink,
}

// {Begin|Commit|Rollback} Transaction Statement
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum TransactionStmtKind {
    TransStmtBegin,
    // semantically identical to BEGIN
    TransStmtStart,
    TransStmtCommit,
    TransStmtRollback,
    TransStmtSavepoint,
    TransStmtRelease,
    TransStmtRollbackTo,
    TransStmtPrepare,
    TransStmtCommitPrepared,
    TransStmtRollbackPrepared,
}

// SET Statement (includes RESET)
// "SET var TO DEFAULT" and "RESET var" are semantically equivalent, but we
// preserve the distinction in VariableSetKind for CreateCommandTag().
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum VariableSetKind {
    // SET var = value
    VarSetValue,
    // SET var TO DEFAULT
    VarSetDefault,
    // SET var FROM CURRENT
    VarSetCurrent,
    // special case for SET TRANSACTION ...
    VarSetMulti,
    // RESET var
    VarReset,
    // RESET ALL
    VarResetAll,
}

// Create View Statement
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum ViewCheckOption {
    NoCheckOption,
    LocalCheckOption,
    CascadedCheckOption,
}

// WithCheckOption -
// representation of WITH CHECK OPTION checks to be applied to new tuples
// when inserting/updating an auto-updatable view, or RLS WITH CHECK
// policies to be applied when inserting/updating a relation with RLS.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum WCOKind {
    // WCO on an auto-updatable view
    WcoViewCheck,
    // RLS INSERT WITH CHECK policy
    WcoRlsInsertCheck,
    // RLS UPDATE WITH CHECK policy
    WcoRlsUpdateCheck,
    // RLS ON CONFLICT DO UPDATE USING policy
    WcoRlsConflictCheck,
}

// XmlExpr - various SQL/XML functions requiring special grammar productions
// 'name' carries the "NAME foo" argument (already XML-escaped).
// 'named_args' and 'arg_names' represent an xml_attribute list.
// 'args' carries all other arguments.
// Note: result type/typmod/collation are not stored, but can be deduced
// from the XmlExprOp.  The type/typmod fields are just used for display
// purposes, and are NOT necessarily the true result type of the node.
#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum XmlExprOp {
    // XMLCONCAT(args)
    IsXmlconcat,
    // XMLELEMENT(name, xml_attributes, args)
    IsXmlelement,
    // XMLFOREST(xml_attributes)
    IsXmlforest,
    // XMLPARSE(text, is_doc, preserve_ws)
    IsXmlparse,
    // XMLPI(name [, args])
    IsXmlpi,
    // XMLROOT(xml, version, standalone)
    IsXmlroot,
    // XMLSERIALIZE(is_document, xmlval)
    IsXmlserialize,
    // xmlval IS DOCUMENT
    IsDocument,
}

#[derive(Debug, Deserialize_repr, Display, PartialEq, Serialize_repr)]
#[repr(u8)]
pub enum XmlOptionType {
    XmloptionDocument,
    XmloptionContent,
}

// A Node is a type that can be referenced from many different types of parsed statements.
#[derive(Debug, Display, Deserialize, PartialEq, Serialize)]
pub enum Node {
    #[serde(rename = "A_ArrayExpr")]
    AArrayExpr(AArrayExpr),
    #[serde(rename = "A_Const")]
    AConst(AConst),
    #[serde(rename = "A_Expr")]
    AExpr(AExpr),
    #[serde(rename = "A_Indices")]
    AIndices(AIndices),
    #[serde(rename = "A_Indirection")]
    AIndirection(AIndirection),
    #[serde(rename = "A_Star")]
    AStar(AStar),
    AccessPriv(AccessPriv),
    Aggref(Aggref),
    Alias(Alias),
    AlterCollationStmt(AlterCollationStmt),
    AlterDatabaseSetStmt(AlterDatabaseSetStmt),
    AlterDatabaseStmt(AlterDatabaseStmt),
    AlterDefaultPrivilegesStmt(AlterDefaultPrivilegesStmt),
    AlterDomainStmt(AlterDomainStmt),
    AlterEnumStmt(AlterEnumStmt),
    AlterEventTrigStmt(AlterEventTrigStmt),
    AlterExtensionContentsStmt(AlterExtensionContentsStmt),
    AlterExtensionStmt(AlterExtensionStmt),
    AlterFdwStmt(AlterFdwStmt),
    AlterForeignServerStmt(AlterForeignServerStmt),
    AlterFunctionStmt(AlterFunctionStmt),
    AlterObjectDependsStmt(AlterObjectDependsStmt),
    AlterObjectSchemaStmt(AlterObjectSchemaStmt),
    AlterOpFamilyStmt(AlterOpFamilyStmt),
    AlterOperatorStmt(AlterOperatorStmt),
    AlterOwnerStmt(AlterOwnerStmt),
    AlterPolicyStmt(AlterPolicyStmt),
    AlterPublicationStmt(AlterPublicationStmt),
    AlterRoleSetStmt(AlterRoleSetStmt),
    AlterRoleStmt(AlterRoleStmt),
    AlterSeqStmt(AlterSeqStmt),
    AlterSubscriptionStmt(AlterSubscriptionStmt),
    AlterSystemStmt(AlterSystemStmt),
    AlterTSConfigurationStmt(AlterTSConfigurationStmt),
    AlterTSDictionaryStmt(AlterTSDictionaryStmt),
    AlterTableCmd(AlterTableCmd),
    AlterTableMoveAllStmt(AlterTableMoveAllStmt),
    AlterTableSpaceOptionsStmt(AlterTableSpaceOptionsStmt),
    AlterTableStmt(AlterTableStmt),
    AlterUserMappingStmt(AlterUserMappingStmt),
    AlternativeSubPlan(AlternativeSubPlan),
    ArrayCoerceExpr(ArrayCoerceExpr),
    ArrayExpr(ArrayExpr),
    ArrayRef(ArrayRef),
    BitString(BitString),
    BoolExpr(BoolExpr),
    BooleanTest(BooleanTest),
    CaseExpr(CaseExpr),
    CaseTestExpr(CaseTestExpr),
    CaseWhen(CaseWhen),
    CheckPointStmt(CheckPointStmt),
    ClosePortalStmt(ClosePortalStmt),
    ClusterStmt(ClusterStmt),
    CoalesceExpr(CoalesceExpr),
    CoerceToDomain(CoerceToDomain),
    CoerceToDomainValue(CoerceToDomainValue),
    CoerceViaIO(CoerceViaIO),
    CollateClause(CollateClause),
    CollateExpr(CollateExpr),
    ColumnDef(ColumnDef),
    ColumnRef(ColumnRef),
    CommentStmt(CommentStmt),
    CommonTableExpr(CommonTableExpr),
    CompositeTypeStmt(CompositeTypeStmt),
    Const(Const),
    Constraint(Constraint),
    ConstraintsSetStmt(ConstraintsSetStmt),
    ConvertRowtypeExpr(ConvertRowtypeExpr),
    CopyStmt(CopyStmt),
    CreateAmStmt(CreateAmStmt),
    CreateCastStmt(CreateCastStmt),
    CreateConversionStmt(CreateConversionStmt),
    CreateDomainStmt(CreateDomainStmt),
    CreateEnumStmt(CreateEnumStmt),
    CreateEventTrigStmt(CreateEventTrigStmt),
    CreateExtensionStmt(CreateExtensionStmt),
    CreateFdwStmt(CreateFdwStmt),
    CreateForeignServerStmt(CreateForeignServerStmt),
    CreateForeignTableStmt(CreateForeignTableStmt),
    CreateFunctionStmt(CreateFunctionStmt),
    CreateOpClassItem(CreateOpClassItem),
    CreateOpClassStmt(CreateOpClassStmt),
    CreateOpFamilyStmt(CreateOpFamilyStmt),
    CreatePLangStmt(CreatePLangStmt),
    CreatePolicyStmt(CreatePolicyStmt),
    CreatePublicationStmt(CreatePublicationStmt),
    CreateRangeStmt(CreateRangeStmt),
    CreateRoleStmt(CreateRoleStmt),
    CreateSchemaStmt(CreateSchemaStmt),
    CreateSeqStmt(CreateSeqStmt),
    CreateStatsStmt(CreateStatsStmt),
    CreateStmt(CreateStmt),
    CreateSubscriptionStmt(CreateSubscriptionStmt),
    CreateTableAsStmt(CreateTableAsStmt),
    CreateTableSpaceStmt(CreateTableSpaceStmt),
    CreateTransformStmt(CreateTransformStmt),
    CreateTrigStmt(CreateTrigStmt),
    CreateUserMappingStmt(CreateUserMappingStmt),
    CreatedbStmt(CreatedbStmt),
    CurrentOfExpr(CurrentOfExpr),
    DeallocateStmt(DeallocateStmt),
    DeclareCursorStmt(DeclareCursorStmt),
    DefElem(DefElem),
    DefineStmt(DefineStmt),
    DeleteStmt(DeleteStmt),
    DiscardStmt(DiscardStmt),
    DoStmt(DoStmt),
    DropOwnedStmt(DropOwnedStmt),
    DropRoleStmt(DropRoleStmt),
    DropStmt(DropStmt),
    DropSubscriptionStmt(DropSubscriptionStmt),
    DropTableSpaceStmt(DropTableSpaceStmt),
    DropUserMappingStmt(DropUserMappingStmt),
    DropdbStmt(DropdbStmt),
    ExecuteStmt(ExecuteStmt),
    ExplainStmt(ExplainStmt),
    Expr(Expr),
    FetchStmt(FetchStmt),
    FieldSelect(FieldSelect),
    FieldStore(FieldStore),
    Float(Float),
    FromExpr(FromExpr),
    FuncCall(FuncCall),
    FuncExpr(FuncExpr),
    FunctionParameter(FunctionParameter),
    GrantRoleStmt(GrantRoleStmt),
    GrantStmt(GrantStmt),
    GroupingFunc(GroupingFunc),
    GroupingSet(GroupingSet),
    ImportForeignSchemaStmt(ImportForeignSchemaStmt),
    IndexElem(IndexElem),
    IndexStmt(IndexStmt),
    InferClause(InferClause),
    InferenceElem(InferenceElem),
    InlineCodeBlock(InlineCodeBlock),
    InsertStmt(InsertStmt),
    Integer(Integer),
    IntoClause(IntoClause),
    JoinExpr(JoinExpr),
    ListenStmt(ListenStmt),
    LoadStmt(LoadStmt),
    LockStmt(LockStmt),
    LockingClause(LockingClause),
    MinMaxExpr(MinMaxExpr),
    MultiAssignRef(MultiAssignRef),
    NamedArgExpr(NamedArgExpr),
    NextValueExpr(NextValueExpr),
    NotifyStmt(NotifyStmt),
    Null(Null),
    NullTest(NullTest),
    ObjectWithArgs(ObjectWithArgs),
    OnConflictClause(OnConflictClause),
    OnConflictExpr(OnConflictExpr),
    OpExpr(OpExpr),
    Param(Param),
    ParamRef(ParamRef),
    PartitionBoundSpec(PartitionBoundSpec),
    PartitionCmd(PartitionCmd),
    PartitionElem(PartitionElem),
    PartitionRangeDatum(PartitionRangeDatum),
    PartitionSpec(PartitionSpec),
    PrepareStmt(PrepareStmt),
    Query(Query),
    RangeFunction(RangeFunction),
    RangeSubselect(RangeSubselect),
    RangeTableFunc(RangeTableFunc),
    RangeTableFuncCol(RangeTableFuncCol),
    RangeTableSample(RangeTableSample),
    RangeTblEntry(RangeTblEntry),
    RangeTblFunction(RangeTblFunction),
    RangeTblRef(RangeTblRef),
    RangeVar(RangeVar),
    ReassignOwnedStmt(ReassignOwnedStmt),
    RefreshMatViewStmt(RefreshMatViewStmt),
    ReindexStmt(ReindexStmt),
    RelabelType(RelabelType),
    RenameStmt(RenameStmt),
    ReplicaIdentityStmt(ReplicaIdentityStmt),
    ResTarget(ResTarget),
    RoleSpec(RoleSpec),
    RowCompareExpr(RowCompareExpr),
    RowExpr(RowExpr),
    RowMarkClause(RowMarkClause),
    RuleStmt(RuleStmt),
    SQLValueFunction(SQLValueFunction),
    ScalarArrayOpExpr(ScalarArrayOpExpr),
    SecLabelStmt(SecLabelStmt),
    SelectStmt(SelectStmt),
    SetOperationStmt(SetOperationStmt),
    SetToDefault(SetToDefault),
    SortBy(SortBy),
    SortGroupClause(SortGroupClause),
    #[serde(rename = "String")]
    StringStruct(StringStruct),
    SubLink(SubLink),
    SubPlan(SubPlan),
    TableFunc(TableFunc),
    TableLikeClause(TableLikeClause),
    TableSampleClause(TableSampleClause),
    TargetEntry(TargetEntry),
    TransactionStmt(TransactionStmt),
    TriggerTransition(TriggerTransition),
    TruncateStmt(TruncateStmt),
    TypeCast(TypeCast),
    TypeName(TypeName),
    UnlistenStmt(UnlistenStmt),
    UpdateStmt(UpdateStmt),
    VacuumStmt(VacuumStmt),
    Var(Var),
    VariableSetStmt(VariableSetStmt),
    VariableShowStmt(VariableShowStmt),
    ViewStmt(ViewStmt),
    WindowClause(WindowClause),
    WindowDef(WindowDef),
    WindowFunc(WindowFunc),
    WithCheckOption(WithCheckOption),
    WithClause(WithClause),
    XmlExpr(XmlExpr),
    XmlSerialize(XmlSerialize),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum AccessPrivWrapper {
    AccessPriv(AccessPriv),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum AliasWrapper {
    Alias(Alias),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum CollateClauseWrapper {
    CollateClause(CollateClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum ColumnDefWrapper {
    ColumnDef(ColumnDef),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum ConstraintWrapper {
    Constraint(Constraint),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum CreateOpClassItemWrapper {
    CreateOpClassItem(CreateOpClassItem),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum CreateStmtWrapper {
    CreateStmt(CreateStmt),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum DefElemWrapper {
    DefElem(DefElem),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum ExprWrapper {
    Expr(Expr),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum FromExprWrapper {
    FromExpr(FromExpr),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum FunctionParameterWrapper {
    FunctionParameter(FunctionParameter),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum GrantStmtWrapper {
    GrantStmt(GrantStmt),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum GroupingSetWrapper {
    GroupingSet(GroupingSet),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum IndexElemWrapper {
    IndexElem(IndexElem),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum InferClauseWrapper {
    InferClause(InferClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum IntoClauseWrapper {
    IntoClause(IntoClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum LockingClauseWrapper {
    LockingClause(LockingClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum ObjectWithArgsWrapper {
    ObjectWithArgs(ObjectWithArgs),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum OnConflictClauseWrapper {
    OnConflictClause(OnConflictClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum OnConflictExprWrapper {
    OnConflictExpr(OnConflictExpr),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum PartitionBoundSpecWrapper {
    PartitionBoundSpec(PartitionBoundSpec),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum PartitionSpecWrapper {
    PartitionSpec(PartitionSpec),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum QueryWrapper {
    Query(Query),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum RangeTableFuncColWrapper {
    RangeTableFuncCol(RangeTableFuncCol),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum RangeTblFunctionWrapper {
    RangeTblFunction(RangeTblFunction),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum RangeVarWrapper {
    RangeVar(RangeVar),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum RoleSpecWrapper {
    RoleSpec(RoleSpec),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum RowMarkClauseWrapper {
    RowMarkClause(RowMarkClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum SelectStmtWrapper {
    SelectStmt(SelectStmt),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum SortByWrapper {
    SortBy(SortBy),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum SortGroupClauseWrapper {
    SortGroupClause(SortGroupClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum StringStructWrapper {
    #[serde(rename = "String")]
    StringStruct(StringStruct),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum TableFuncWrapper {
    TableFunc(TableFunc),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum TableSampleClauseWrapper {
    TableSampleClause(TableSampleClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum TypeNameWrapper {
    TypeName(TypeName),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum VariableSetStmtWrapper {
    VariableSetStmt(VariableSetStmt),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum WindowClauseWrapper {
    WindowClause(WindowClause),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum WindowDefWrapper {
    WindowDef(WindowDef),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum WithCheckOptionWrapper {
    WithCheckOption(WithCheckOption),
}

#[derive(Debug, Deserialize, PartialEq, Serialize)]
pub enum WithClauseWrapper {
    WithClause(WithClause),
}

// end generated code >>>
